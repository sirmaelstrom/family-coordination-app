---
phase: 02-recipe-management
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/FamilyCoordinationApp/Services/IngredientParser.cs
  - tests/FamilyCoordinationApp.Tests/FamilyCoordinationApp.Tests.csproj
  - tests/FamilyCoordinationApp.Tests/Services/IngredientParserTests.cs
autonomous: true

must_haves:
  truths:
    - "Parser extracts quantity from '2 cups flour' as 2"
    - "Parser extracts unit from '2 cups flour' as 'cups'"
    - "Parser extracts name from '2 cups flour' as 'flour'"
    - "Parser handles fractions like '1/2 cup milk'"
    - "Parser handles mixed fractions like '1 1/2 cups flour'"
    - "Parser handles unitless quantities like '3 eggs'"
    - "Parser extracts notes in parentheses"
  artifacts:
    - path: "src/FamilyCoordinationApp/Services/IngredientParser.cs"
      provides: "Ingredient parsing service"
      contains: "ParseIngredient"
    - path: "tests/FamilyCoordinationApp.Tests/Services/IngredientParserTests.cs"
      provides: "Parser unit tests"
      contains: "[Fact]"
  key_links:
    - from: "IngredientParserTests.cs"
      to: "IngredientParser.cs"
      via: "instantiation and method calls"
      pattern: "IngredientParser"
---

<objective>
Create ingredient parser service using TDD to parse natural language ingredient text into structured data.

Purpose: Enable hybrid ingredient entry where users type "2 1/2 cups all-purpose flour, sifted" and get structured fields (quantity=2.5, unit=cups, name=all-purpose flour, notes=sifted).
Output: IngredientParser service with comprehensive tests covering common ingredient patterns.
</objective>

<execution_context>
@/home/sirm/.claude/get-shit-done/workflows/execute-plan.md
@/home/sirm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-recipe-management/02-CONTEXT.md
@.planning/phases/02-recipe-management/02-RESEARCH.md

# Reference the Fractions library usage from research
# Parser should use Fractions library for handling mixed fractions
</context>

<feature>
  <name>Ingredient Parser</name>
  <files>
    src/FamilyCoordinationApp/Services/IngredientParser.cs
    tests/FamilyCoordinationApp.Tests/Services/IngredientParserTests.cs
  </files>
  <behavior>
Parser accepts natural language ingredient text and returns structured ParsedIngredient:

**Input formats to handle:**
- "2 cups flour" -> quantity=2, unit=cups, name=flour
- "1/2 cup milk" -> quantity=0.5, unit=cup, name=milk
- "1 1/2 cups flour" -> quantity=1.5, unit=cups, name=flour
- "3 eggs" -> quantity=3, unit=null, name=eggs
- "salt to taste" -> quantity=null, unit=null, name=salt to taste
- "2 lbs chicken breast, boneless" -> quantity=2, unit=lbs, name=chicken breast, notes=boneless
- "1 (14 oz) can diced tomatoes" -> quantity=1, unit=can, name=diced tomatoes, notes=14 oz
- "2-3 cloves garlic, minced" -> quantity=2.5 (avg), unit=cloves, name=garlic, notes=minced

**Supported units (US + metric):**
- Volume: cup, cups, tbsp, tablespoon, tsp, teaspoon, ml, liter, liters, oz, ounce, ounces, fl oz
- Weight: lb, lbs, pound, pounds, g, gram, grams, kg, kilogram, kilograms
- Count: each, whole, piece, pieces, clove, cloves, can, cans, package, packages, bunch, bunches

**Edge cases:**
- Unicode fractions: "½ cup" -> 0.5
- Range: "2-3 cups" -> use midpoint (2.5)
- Notes in parentheses: "(optional)" -> notes field
- Notes after comma: ", chopped" -> notes field
- Unparseable portions: preserve in rawUnparsed field for user review
  </behavior>
  <implementation>
Create ParsedIngredient record:
```csharp
public record ParsedIngredient(
    decimal? Quantity,
    string? Unit,
    string Name,
    string? Notes,
    string? RawUnparsed,  // Portions that couldn't be parsed
    bool IsComplete       // True if fully parsed
);
```

Parser implementation approach (rule-based state machine, not regex chains):
1. Tokenize input by whitespace
2. Extract quantity (number, fraction, mixed fraction, range) from start
3. Match unit from known list
4. Remaining tokens are ingredient name
5. Extract notes from parentheses or after comma
6. Handle edge cases gracefully with RawUnparsed

Use Fractions library for fraction handling.
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>RED: Create test project and write failing tests for ingredient parser</name>
  <files>
    tests/FamilyCoordinationApp.Tests/FamilyCoordinationApp.Tests.csproj
    tests/FamilyCoordinationApp.Tests/Services/IngredientParserTests.cs
  </files>
  <action>
1. Create test project if it doesn't exist:
   ```bash
   mkdir -p tests/FamilyCoordinationApp.Tests
   cd tests/FamilyCoordinationApp.Tests
   dotnet new xunit
   dotnet add reference ../../src/FamilyCoordinationApp/FamilyCoordinationApp.csproj
   ```

2. Add test project to solution (if solution exists) or verify it's referenced.

3. Create IngredientParserTests.cs with failing tests:
   ```csharp
   using FamilyCoordinationApp.Services;

   namespace FamilyCoordinationApp.Tests.Services;

   public class IngredientParserTests
   {
       private readonly IngredientParser _parser = new();

       [Theory]
       [InlineData("2 cups flour", 2, "cups", "flour")]
       [InlineData("1 cup sugar", 1, "cup", "sugar")]
       [InlineData("3 tbsp olive oil", 3, "tbsp", "olive oil")]
       [InlineData("500 g chicken breast", 500, "g", "chicken breast")]
       public void ParseIngredient_SimpleFormat_ExtractsAllFields(
           string input, decimal expectedQty, string expectedUnit, string expectedName)
       {
           var result = _parser.ParseIngredient(input);

           Assert.Equal(expectedQty, result.Quantity);
           Assert.Equal(expectedUnit, result.Unit);
           Assert.Equal(expectedName, result.Name);
           Assert.True(result.IsComplete);
       }

       [Theory]
       [InlineData("1/2 cup milk", 0.5)]
       [InlineData("1/4 tsp salt", 0.25)]
       [InlineData("3/4 cup water", 0.75)]
       public void ParseIngredient_SimpleFraction_ExtractsQuantity(string input, decimal expectedQty)
       {
           var result = _parser.ParseIngredient(input);

           Assert.Equal(expectedQty, result.Quantity);
       }

       [Theory]
       [InlineData("1 1/2 cups flour", 1.5)]
       [InlineData("2 1/4 cups sugar", 2.25)]
       [InlineData("3 3/4 lbs beef", 3.75)]
       public void ParseIngredient_MixedFraction_ExtractsQuantity(string input, decimal expectedQty)
       {
           var result = _parser.ParseIngredient(input);

           Assert.Equal(expectedQty, result.Quantity);
       }

       [Theory]
       [InlineData("3 eggs", 3, "eggs")]
       [InlineData("2 apples", 2, "apples")]
       [InlineData("1 onion", 1, "onion")]
       public void ParseIngredient_NoUnit_ExtractsQuantityAndName(
           string input, decimal expectedQty, string expectedName)
       {
           var result = _parser.ParseIngredient(input);

           Assert.Equal(expectedQty, result.Quantity);
           Assert.Null(result.Unit);
           Assert.Equal(expectedName, result.Name);
       }

       [Theory]
       [InlineData("salt to taste")]
       [InlineData("pepper")]
       [InlineData("fresh parsley")]
       public void ParseIngredient_NoQuantity_ExtractsNameOnly(string input)
       {
           var result = _parser.ParseIngredient(input);

           Assert.Null(result.Quantity);
           Assert.Null(result.Unit);
           Assert.Equal(input, result.Name);
       }

       [Theory]
       [InlineData("2 lbs chicken breast, boneless", "boneless")]
       [InlineData("1 cup flour, sifted", "sifted")]
       [InlineData("3 cloves garlic, minced", "minced")]
       public void ParseIngredient_NotesAfterComma_ExtractsNotes(string input, string expectedNotes)
       {
           var result = _parser.ParseIngredient(input);

           Assert.Equal(expectedNotes, result.Notes);
       }

       [Theory]
       [InlineData("1 (14 oz) can diced tomatoes", "14 oz")]
       [InlineData("2 cups cheese (optional)", "optional")]
       public void ParseIngredient_NotesInParentheses_ExtractsNotes(string input, string expectedNotes)
       {
           var result = _parser.ParseIngredient(input);

           Assert.Contains(expectedNotes, result.Notes);
       }

       [Theory]
       [InlineData("2-3 cups flour", 2.5)]
       [InlineData("3-4 cloves garlic", 3.5)]
       public void ParseIngredient_Range_UsesMiddleValue(string input, decimal expectedQty)
       {
           var result = _parser.ParseIngredient(input);

           Assert.Equal(expectedQty, result.Quantity);
       }

       [Theory]
       [InlineData("½ cup milk", 0.5)]
       [InlineData("¼ tsp salt", 0.25)]
       [InlineData("¾ cup water", 0.75)]
       public void ParseIngredient_UnicodeFraction_ExtractsQuantity(string input, decimal expectedQty)
       {
           var result = _parser.ParseIngredient(input);

           Assert.Equal(expectedQty, result.Quantity);
       }

       [Fact]
       public void ParseIngredient_EmptyString_ReturnsEmptyResult()
       {
           var result = _parser.ParseIngredient("");

           Assert.Equal(string.Empty, result.Name);
           Assert.False(result.IsComplete);
       }

       [Fact]
       public void ParseIngredient_WhitespaceOnly_ReturnsEmptyResult()
       {
           var result = _parser.ParseIngredient("   ");

           Assert.Equal(string.Empty, result.Name);
           Assert.False(result.IsComplete);
       }
   }
   ```

4. Create stub IngredientParser.cs that compiles but fails tests:
   ```csharp
   namespace FamilyCoordinationApp.Services;

   public record ParsedIngredient(
       decimal? Quantity,
       string? Unit,
       string Name,
       string? Notes,
       string? RawUnparsed,
       bool IsComplete
   );

   public class IngredientParser
   {
       public ParsedIngredient ParseIngredient(string input)
       {
           // Stub - will be implemented in GREEN phase
           throw new NotImplementedException();
       }
   }
   ```

5. Run tests to verify they FAIL:
   ```bash
   dotnet test tests/FamilyCoordinationApp.Tests
   ```

6. Commit with message: `test(02-02): add failing tests for ingredient parser`
  </action>
  <verify>
    `dotnet test tests/FamilyCoordinationApp.Tests` runs and ALL tests FAIL (NotImplementedException)
  </verify>
  <done>Test project created, 16+ test cases written, all tests fail with NotImplementedException</done>
</task>

<task type="auto">
  <name>GREEN: Implement ingredient parser to pass all tests</name>
  <files>
    src/FamilyCoordinationApp/Services/IngredientParser.cs
  </files>
  <action>
Implement IngredientParser using tokenization and rule-based parsing:

```csharp
using System.Text.RegularExpressions;
using Fractions;

namespace FamilyCoordinationApp.Services;

public record ParsedIngredient(
    decimal? Quantity,
    string? Unit,
    string Name,
    string? Notes,
    string? RawUnparsed,
    bool IsComplete
);

public partial class IngredientParser
{
    private static readonly HashSet<string> KnownUnits = new(StringComparer.OrdinalIgnoreCase)
    {
        // Volume
        "cup", "cups", "c",
        "tbsp", "tablespoon", "tablespoons", "tbs", "T",
        "tsp", "teaspoon", "teaspoons", "t",
        "ml", "milliliter", "milliliters",
        "l", "liter", "liters", "litre", "litres",
        "fl oz", "fluid ounce", "fluid ounces",
        "oz", "ounce", "ounces",
        "pint", "pints", "pt",
        "quart", "quarts", "qt",
        "gallon", "gallons", "gal",

        // Weight
        "lb", "lbs", "pound", "pounds",
        "g", "gram", "grams",
        "kg", "kilogram", "kilograms",

        // Count/Other
        "clove", "cloves",
        "can", "cans",
        "package", "packages", "pkg",
        "bunch", "bunches",
        "head", "heads",
        "slice", "slices",
        "piece", "pieces",
        "stick", "sticks",
        "sprig", "sprigs",
        "pinch", "pinches",
        "dash", "dashes"
    };

    private static readonly Dictionary<char, decimal> UnicodeFractions = new()
    {
        { '½', 0.5m },
        { '⅓', 1m/3m },
        { '⅔', 2m/3m },
        { '¼', 0.25m },
        { '¾', 0.75m },
        { '⅕', 0.2m },
        { '⅖', 0.4m },
        { '⅗', 0.6m },
        { '⅘', 0.8m },
        { '⅙', 1m/6m },
        { '⅚', 5m/6m },
        { '⅛', 0.125m },
        { '⅜', 0.375m },
        { '⅝', 0.625m },
        { '⅞', 0.875m }
    };

    public ParsedIngredient ParseIngredient(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
        {
            return new ParsedIngredient(null, null, string.Empty, null, null, false);
        }

        var trimmed = input.Trim();

        // Extract notes from parentheses
        var (textWithoutParens, parenNotes) = ExtractParentheses(trimmed);

        // Extract notes after comma
        var (mainText, commaNotes) = ExtractCommaNote(textWithoutParens);

        // Combine notes
        var allNotes = CombineNotes(parenNotes, commaNotes);

        // Parse quantity and remaining text
        var (quantity, afterQuantity) = ExtractQuantity(mainText);

        // Parse unit and name from remaining
        var (unit, name) = ExtractUnitAndName(afterQuantity);

        // Determine if parsing was complete
        var isComplete = !string.IsNullOrWhiteSpace(name);

        return new ParsedIngredient(
            quantity,
            unit,
            name.Trim(),
            string.IsNullOrWhiteSpace(allNotes) ? null : allNotes.Trim(),
            null,
            isComplete
        );
    }

    private static (string text, string? notes) ExtractParentheses(string input)
    {
        var parenRegex = ParenthesesRegex();
        var matches = parenRegex.Matches(input);

        if (matches.Count == 0)
            return (input, null);

        var notes = string.Join(", ", matches.Select(m => m.Groups[1].Value));
        var text = parenRegex.Replace(input, " ").Trim();
        text = MultipleSpacesRegex().Replace(text, " ");

        return (text, notes);
    }

    private static (string text, string? notes) ExtractCommaNote(string input)
    {
        var commaIdx = input.IndexOf(',');
        if (commaIdx < 0)
            return (input, null);

        return (
            input[..commaIdx].Trim(),
            input[(commaIdx + 1)..].Trim()
        );
    }

    private static string? CombineNotes(string? note1, string? note2)
    {
        if (string.IsNullOrWhiteSpace(note1) && string.IsNullOrWhiteSpace(note2))
            return null;
        if (string.IsNullOrWhiteSpace(note1))
            return note2;
        if (string.IsNullOrWhiteSpace(note2))
            return note1;
        return $"{note1}, {note2}";
    }

    private static (decimal? quantity, string remaining) ExtractQuantity(string input)
    {
        var trimmed = input.Trim();
        if (string.IsNullOrEmpty(trimmed))
            return (null, string.Empty);

        // Check for range (e.g., "2-3")
        var rangeMatch = RangeRegex().Match(trimmed);
        if (rangeMatch.Success)
        {
            var low = decimal.Parse(rangeMatch.Groups[1].Value);
            var high = decimal.Parse(rangeMatch.Groups[2].Value);
            var avg = (low + high) / 2m;
            return (avg, trimmed[rangeMatch.Length..].Trim());
        }

        // Check for mixed fraction (e.g., "1 1/2")
        var mixedMatch = MixedFractionRegex().Match(trimmed);
        if (mixedMatch.Success)
        {
            var whole = decimal.Parse(mixedMatch.Groups[1].Value);
            var num = decimal.Parse(mixedMatch.Groups[2].Value);
            var den = decimal.Parse(mixedMatch.Groups[3].Value);
            return (whole + num / den, trimmed[mixedMatch.Length..].Trim());
        }

        // Check for simple fraction (e.g., "1/2")
        var fractionMatch = SimpleFractionRegex().Match(trimmed);
        if (fractionMatch.Success)
        {
            var num = decimal.Parse(fractionMatch.Groups[1].Value);
            var den = decimal.Parse(fractionMatch.Groups[2].Value);
            return (num / den, trimmed[fractionMatch.Length..].Trim());
        }

        // Check for Unicode fraction at start
        if (trimmed.Length > 0 && UnicodeFractions.TryGetValue(trimmed[0], out var unicodeVal))
        {
            return (unicodeVal, trimmed[1..].Trim());
        }

        // Check for whole number followed by Unicode fraction (e.g., "1½")
        var unicodeMixedMatch = UnicodeMixedRegex().Match(trimmed);
        if (unicodeMixedMatch.Success)
        {
            var whole = decimal.Parse(unicodeMixedMatch.Groups[1].Value);
            var fractionChar = unicodeMixedMatch.Groups[2].Value[0];
            if (UnicodeFractions.TryGetValue(fractionChar, out var fracVal))
            {
                return (whole + fracVal, trimmed[unicodeMixedMatch.Length..].Trim());
            }
        }

        // Check for simple number (e.g., "2", "2.5")
        var numberMatch = SimpleNumberRegex().Match(trimmed);
        if (numberMatch.Success)
        {
            return (decimal.Parse(numberMatch.Value), trimmed[numberMatch.Length..].Trim());
        }

        // No quantity found
        return (null, trimmed);
    }

    private static (string? unit, string name) ExtractUnitAndName(string input)
    {
        var trimmed = input.Trim();
        if (string.IsNullOrEmpty(trimmed))
            return (null, string.Empty);

        var words = trimmed.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        if (words.Length == 0)
            return (null, string.Empty);

        // Check if first word is a unit
        if (KnownUnits.Contains(words[0]))
        {
            var unit = words[0];
            var name = string.Join(' ', words.Skip(1));
            return (unit, name);
        }

        // Check for two-word units like "fl oz"
        if (words.Length >= 2)
        {
            var twoWordUnit = $"{words[0]} {words[1]}";
            if (KnownUnits.Contains(twoWordUnit))
            {
                var name = string.Join(' ', words.Skip(2));
                return (twoWordUnit, name);
            }
        }

        // No unit found - entire remaining text is the name
        return (null, trimmed);
    }

    [GeneratedRegex(@"\(([^)]+)\)")]
    private static partial Regex ParenthesesRegex();

    [GeneratedRegex(@"\s+")]
    private static partial Regex MultipleSpacesRegex();

    [GeneratedRegex(@"^(\d+(?:\.\d+)?)\s*-\s*(\d+(?:\.\d+)?)")]
    private static partial Regex RangeRegex();

    [GeneratedRegex(@"^(\d+)\s+(\d+)/(\d+)")]
    private static partial Regex MixedFractionRegex();

    [GeneratedRegex(@"^(\d+)/(\d+)")]
    private static partial Regex SimpleFractionRegex();

    [GeneratedRegex(@"^(\d+)([½⅓⅔¼¾⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞])")]
    private static partial Regex UnicodeMixedRegex();

    [GeneratedRegex(@"^(\d+(?:\.\d+)?)")]
    private static partial Regex SimpleNumberRegex();
}
```

Run tests to verify they PASS:
```bash
dotnet test tests/FamilyCoordinationApp.Tests
```

Commit with message: `feat(02-02): implement ingredient parser`
  </action>
  <verify>
    `dotnet test tests/FamilyCoordinationApp.Tests` runs and ALL tests PASS
  </verify>
  <done>Ingredient parser implemented, all tests pass</done>
</task>

<task type="auto">
  <name>REFACTOR: Clean up parser if needed, verify tests still pass</name>
  <files>
    src/FamilyCoordinationApp/Services/IngredientParser.cs
  </files>
  <action>
Review the implementation and refactor if any obvious improvements exist:

1. Verify no code duplication
2. Ensure method names are clear
3. Consider adding XML documentation comments for public API
4. Verify regex patterns are correct and performant (using source generators)

If no changes needed, skip this task.

If changes made:
```bash
dotnet test tests/FamilyCoordinationApp.Tests
```

Commit only if changes were made: `refactor(02-02): clean up ingredient parser`
  </action>
  <verify>
    `dotnet test tests/FamilyCoordinationApp.Tests` runs and ALL tests PASS
  </verify>
  <done>Parser refactored (or skipped if no improvements needed), tests pass</done>
</task>

</tasks>

<verification>
1. Test project exists at tests/FamilyCoordinationApp.Tests
2. IngredientParserTests.cs has 16+ test cases
3. IngredientParser.cs implements ParseIngredient method
4. All tests pass with `dotnet test`
5. Parser handles: simple quantities, fractions, mixed fractions, Unicode fractions, ranges, notes, unitless
</verification>

<success_criteria>
- RED phase: All tests written and failing
- GREEN phase: All tests passing
- REFACTOR phase: Code is clean (or no refactoring needed)
- Parser correctly handles all documented input formats
- Parser uses Fractions library concepts (even if implemented directly for performance)
</success_criteria>

<output>
After completion, create `.planning/phases/02-recipe-management/02-02-SUMMARY.md`
</output>
