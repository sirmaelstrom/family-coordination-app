---
phase: 06-recipe-import
plan: 03
type: execute
wave: 2
depends_on: [06-01, 06-02]
files_modified:
  - src/FamilyCoordinationApp/Services/RecipeImportService.cs
  - src/FamilyCoordinationApp/Program.cs
autonomous: true

must_haves:
  truths:
    - "RecipeImportService validates URL before fetching"
    - "Import parses schema.org ingredients through existing IngredientParser"
    - "Import returns clear error messages when extraction fails"
    - "Imported recipes have SourceUrl populated"
  artifacts:
    - path: "src/FamilyCoordinationApp/Services/RecipeImportService.cs"
      provides: "URL → Recipe entity orchestration with graceful degradation"
      contains: "ImportFromUrlAsync"
  key_links:
    - from: "RecipeImportService"
      to: "UrlValidator"
      via: "dependency injection"
      pattern: "IUrlValidator"
    - from: "RecipeImportService"
      to: "RecipeScraperService"
      via: "dependency injection"
      pattern: "IRecipeScraperService"
    - from: "RecipeImportService"
      to: "IngredientParser"
      via: "ingredient string parsing"
      pattern: "IIngredientParser"
---

<objective>
Create RecipeImportService to orchestrate the full import flow: URL validation → HTML fetch → JSON-LD extraction → Recipe entity creation.

Purpose: Provide single entry point for recipe import with proper error handling and graceful degradation.
Output: RecipeImportService that returns Recipe entities or descriptive errors.
</objective>

<execution_context>
@/home/sirm/.claude/get-shit-done/workflows/execute-plan.md
@/home/sirm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-recipe-import/06-RESEARCH.md
@.planning/phases/06-recipe-import/06-01-SUMMARY.md
@.planning/phases/06-recipe-import/06-02-SUMMARY.md
@src/FamilyCoordinationApp/Services/IngredientParser.cs
@src/FamilyCoordinationApp/Services/RecipeService.cs
@src/FamilyCoordinationApp/Data/Entities/Recipe.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RecipeImportResult class for operation outcomes</name>
  <files>src/FamilyCoordinationApp/Services/RecipeImportService.cs</files>
  <action>
Create result type at the top of RecipeImportService.cs for import operation outcomes:

```csharp
namespace FamilyCoordinationApp.Services;

/// <summary>
/// Result of a recipe import operation.
/// </summary>
public class RecipeImportResult
{
    public bool Success { get; private set; }
    public Recipe? Recipe { get; private set; }
    public string? ErrorMessage { get; private set; }
    public RecipeImportErrorType ErrorType { get; private set; }

    /// <summary>
    /// Partially extracted data for manual completion when full extraction fails.
    /// </summary>
    public PartialRecipeData? PartialData { get; private set; }

    public static RecipeImportResult Succeeded(Recipe recipe) => new()
    {
        Success = true,
        Recipe = recipe
    };

    public static RecipeImportResult Failed(string errorMessage, RecipeImportErrorType errorType, PartialRecipeData? partialData = null) => new()
    {
        Success = false,
        ErrorMessage = errorMessage,
        ErrorType = errorType,
        PartialData = partialData
    };
}

public enum RecipeImportErrorType
{
    InvalidUrl,
    FetchFailed,
    ParsingFailed,
    ValidationFailed
}

/// <summary>
/// Partially extracted recipe data for manual completion.
/// </summary>
public class PartialRecipeData
{
    public string? Name { get; set; }
    public string? Description { get; set; }
    public string? Instructions { get; set; }
    public List<string>? IngredientStrings { get; set; }
    public string? ImageUrl { get; set; }
    public int? PrepTimeMinutes { get; set; }
    public int? CookTimeMinutes { get; set; }
    public int? Servings { get; set; }
}
```
  </action>
  <verify>File compiles without errors</verify>
  <done>RecipeImportResult class exists with Success, Failed, and PartialData support</done>
</task>

<task type="auto">
  <name>Task 2: Create RecipeImportService with import orchestration</name>
  <files>src/FamilyCoordinationApp/Services/RecipeImportService.cs</files>
  <action>
Add RecipeImportService class after the result types:

```csharp
using System.Text.Json;
using System.Text.RegularExpressions;
using FamilyCoordinationApp.Data.Entities;
using FamilyCoordinationApp.Models.SchemaOrg;

public interface IRecipeImportService
{
    /// <summary>
    /// Imports recipe from URL, returning Recipe entity or error with partial data.
    /// </summary>
    Task<RecipeImportResult> ImportFromUrlAsync(string url, int householdId, int userId, CancellationToken cancellationToken = default);
}

public class RecipeImportService : IRecipeImportService
{
    private readonly IUrlValidator _urlValidator;
    private readonly IRecipeScraperService _scraperService;
    private readonly IIngredientParser _ingredientParser;
    private readonly ILogger<RecipeImportService> _logger;

    public RecipeImportService(
        IUrlValidator urlValidator,
        IRecipeScraperService scraperService,
        IIngredientParser ingredientParser,
        ILogger<RecipeImportService> logger)
    {
        _urlValidator = urlValidator;
        _scraperService = scraperService;
        _ingredientParser = ingredientParser;
        _logger = logger;
    }

    public async Task<RecipeImportResult> ImportFromUrlAsync(string url, int householdId, int userId, CancellationToken cancellationToken = default)
    {
        // Step 1: Validate URL (SSRF protection)
        var (isValid, validationError) = _urlValidator.ValidateUrl(url);
        if (!isValid)
        {
            _logger.LogWarning("URL validation failed for {Url}: {Error}", url, validationError);
            return RecipeImportResult.Failed(validationError!, RecipeImportErrorType.InvalidUrl);
        }

        // Step 2: Fetch HTML and extract JSON-LD
        RecipeSchema? schema;
        try
        {
            schema = await _scraperService.ScrapeRecipeAsync(url, cancellationToken);
        }
        catch (HttpRequestException ex)
        {
            _logger.LogWarning(ex, "Failed to fetch recipe from {Url}", url);
            return RecipeImportResult.Failed(
                $"Could not fetch the recipe page. The site may be unavailable or blocking requests. Error: {ex.Message}",
                RecipeImportErrorType.FetchFailed);
        }

        // Step 3: Check if we got any data
        if (schema == null)
        {
            _logger.LogWarning("No JSON-LD Recipe found at {Url}", url);
            return RecipeImportResult.Failed(
                "Could not find recipe data on this page. The site may not use standard recipe markup.",
                RecipeImportErrorType.ParsingFailed);
        }

        // Step 4: Validate required fields
        var partialData = ExtractPartialData(schema);

        if (string.IsNullOrWhiteSpace(schema.Name))
        {
            return RecipeImportResult.Failed(
                "Could not extract recipe name from the page.",
                RecipeImportErrorType.ValidationFailed,
                partialData);
        }

        if (schema.RecipeIngredient == null || schema.RecipeIngredient.Length == 0)
        {
            return RecipeImportResult.Failed(
                "Could not extract ingredients from the page. Please add ingredients manually.",
                RecipeImportErrorType.ValidationFailed,
                partialData);
        }

        // Step 5: Convert to Recipe entity
        var recipe = ConvertToRecipeEntity(schema, url, householdId, userId);

        _logger.LogInformation("Successfully imported recipe '{Name}' from {Url}", recipe.Name, url);

        return RecipeImportResult.Succeeded(recipe);
    }

    private Recipe ConvertToRecipeEntity(RecipeSchema schema, string sourceUrl, int householdId, int userId)
    {
        var recipe = new Recipe
        {
            HouseholdId = householdId,
            Name = schema.Name!.Trim(),
            Description = schema.Description?.Trim(),
            Instructions = ExtractInstructions(schema.RecipeInstructions),
            SourceUrl = sourceUrl,
            Servings = ExtractServings(schema.RecipeYield),
            PrepTimeMinutes = ParseIsoDuration(schema.PrepTime),
            CookTimeMinutes = ParseIsoDuration(schema.CookTime),
            CreatedByUserId = userId,
            CreatedAt = DateTime.UtcNow,
            Ingredients = new List<RecipeIngredient>()
        };

        // Parse ingredients using existing IngredientParser
        var sortOrder = 0;
        foreach (var ingredientString in schema.RecipeIngredient!)
        {
            if (string.IsNullOrWhiteSpace(ingredientString))
                continue;

            try
            {
                var parsed = _ingredientParser.ParseIngredient(ingredientString);

                recipe.Ingredients.Add(new RecipeIngredient
                {
                    HouseholdId = householdId,
                    Name = parsed.Name,
                    Quantity = parsed.Quantity,
                    Unit = parsed.Unit,
                    Notes = parsed.Notes,
                    SortOrder = sortOrder++
                });
            }
            catch (ArgumentException)
            {
                // If parsing fails, add as raw text with no quantity/unit
                recipe.Ingredients.Add(new RecipeIngredient
                {
                    HouseholdId = householdId,
                    Name = ingredientString.Trim(),
                    SortOrder = sortOrder++
                });
            }
        }

        return recipe;
    }

    private static string? ExtractInstructions(object? recipeInstructions)
    {
        if (recipeInstructions == null)
            return null;

        // Handle string format
        if (recipeInstructions is string str)
            return str.Trim();

        // Handle JsonElement (from deserialization)
        if (recipeInstructions is JsonElement element)
        {
            // String
            if (element.ValueKind == JsonValueKind.String)
                return element.GetString()?.Trim();

            // Array of HowToStep or strings
            if (element.ValueKind == JsonValueKind.Array)
            {
                var steps = new List<string>();
                var stepNumber = 1;

                foreach (var item in element.EnumerateArray())
                {
                    string? stepText = null;

                    if (item.ValueKind == JsonValueKind.String)
                    {
                        stepText = item.GetString();
                    }
                    else if (item.ValueKind == JsonValueKind.Object)
                    {
                        // HowToStep format
                        if (item.TryGetProperty("text", out var textProp))
                            stepText = textProp.GetString();
                        else if (item.TryGetProperty("name", out var nameProp))
                            stepText = nameProp.GetString();
                    }

                    if (!string.IsNullOrWhiteSpace(stepText))
                    {
                        steps.Add($"{stepNumber}. {stepText.Trim()}");
                        stepNumber++;
                    }
                }

                return steps.Count > 0 ? string.Join("\n\n", steps) : null;
            }
        }

        return recipeInstructions.ToString()?.Trim();
    }

    private static int? ExtractServings(object? recipeYield)
    {
        if (recipeYield == null)
            return null;

        // Handle JsonElement
        if (recipeYield is JsonElement element)
        {
            if (element.ValueKind == JsonValueKind.Number)
                return element.GetInt32();

            if (element.ValueKind == JsonValueKind.String)
            {
                var str = element.GetString();
                return ParseServingsString(str);
            }
        }

        // Handle direct types
        if (recipeYield is int intVal)
            return intVal;

        if (recipeYield is string strVal)
            return ParseServingsString(strVal);

        return null;
    }

    private static int? ParseServingsString(string? str)
    {
        if (string.IsNullOrWhiteSpace(str))
            return null;

        // Extract first number from string like "4 servings" or "Makes 6"
        var match = Regex.Match(str, @"\d+");
        if (match.Success && int.TryParse(match.Value, out var servings))
            return servings;

        return null;
    }

    private static int? ParseIsoDuration(string? duration)
    {
        if (string.IsNullOrWhiteSpace(duration))
            return null;

        // ISO 8601 duration: PT15M (15 minutes), PT1H30M (90 minutes)
        var match = Regex.Match(duration, @"PT(?:(\d+)H)?(?:(\d+)M)?", RegexOptions.IgnoreCase);
        if (!match.Success)
            return null;

        var hours = match.Groups[1].Success ? int.Parse(match.Groups[1].Value) : 0;
        var minutes = match.Groups[2].Success ? int.Parse(match.Groups[2].Value) : 0;

        var totalMinutes = hours * 60 + minutes;
        return totalMinutes > 0 ? totalMinutes : null;
    }

    private static PartialRecipeData ExtractPartialData(RecipeSchema schema)
    {
        return new PartialRecipeData
        {
            Name = schema.Name,
            Description = schema.Description,
            Instructions = ExtractInstructions(schema.RecipeInstructions),
            IngredientStrings = schema.RecipeIngredient?.ToList(),
            ImageUrl = ExtractImageUrl(schema.Image),
            PrepTimeMinutes = ParseIsoDuration(schema.PrepTime),
            CookTimeMinutes = ParseIsoDuration(schema.CookTime),
            Servings = ExtractServings(schema.RecipeYield)
        };
    }

    private static string? ExtractImageUrl(object? image)
    {
        if (image == null)
            return null;

        if (image is string str)
            return str;

        if (image is JsonElement element)
        {
            if (element.ValueKind == JsonValueKind.String)
                return element.GetString();

            // Array of images - take first
            if (element.ValueKind == JsonValueKind.Array)
            {
                foreach (var item in element.EnumerateArray())
                {
                    if (item.ValueKind == JsonValueKind.String)
                        return item.GetString();
                    if (item.ValueKind == JsonValueKind.Object && item.TryGetProperty("url", out var urlProp))
                        return urlProp.GetString();
                }
            }

            // ImageObject
            if (element.ValueKind == JsonValueKind.Object && element.TryGetProperty("url", out var url))
                return url.GetString();
        }

        return null;
    }
}
```

Key features:
- Uses UrlValidator for SSRF protection
- Uses RecipeScraperService for fetch and extraction
- Uses existing IngredientParser for ingredient string parsing
- Handles ISO 8601 duration parsing for prep/cook times
- Handles multiple JSON-LD instruction formats (string, HowToStep array)
- Returns partial data on failure for manual completion
  </action>
  <verify>`dotnet build` passes, RecipeImportService.cs contains ImportFromUrlAsync method</verify>
  <done>RecipeImportService orchestrates import flow with graceful error handling</done>
</task>

<task type="auto">
  <name>Task 3: Register RecipeImportService in DI container</name>
  <files>src/FamilyCoordinationApp/Program.cs</files>
  <action>
Add RecipeImportService registration in Program.cs with other service registrations:

```csharp
builder.Services.AddScoped<IRecipeImportService, RecipeImportService>();
```
  </action>
  <verify>`dotnet build` passes, IRecipeImportService is registered in Program.cs</verify>
  <done>RecipeImportService registered in DI container</done>
</task>

</tasks>

<verification>
1. `dotnet build src/FamilyCoordinationApp` - No compilation errors
2. grep -q "ImportFromUrlAsync" src/FamilyCoordinationApp/Services/RecipeImportService.cs
3. grep -q "IUrlValidator" src/FamilyCoordinationApp/Services/RecipeImportService.cs (SSRF protection)
4. grep -q "IIngredientParser" src/FamilyCoordinationApp/Services/RecipeImportService.cs (ingredient parsing)
5. grep -q "SourceUrl" src/FamilyCoordinationApp/Services/RecipeImportService.cs (tracks source)
6. grep -q "IRecipeImportService" src/FamilyCoordinationApp/Program.cs (registered)
</verification>

<success_criteria>
- RecipeImportService validates URL before fetching
- Import uses existing IngredientParser for ingredient strings
- Import returns clear error messages with partial data on failure
- Imported recipes have SourceUrl populated
- ISO 8601 duration parsed for prep/cook times
- Solution builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/06-recipe-import/06-03-SUMMARY.md`
</output>
