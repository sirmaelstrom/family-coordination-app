---
phase: 06-recipe-import
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/FamilyCoordinationApp/Services/RecipeScraperService.cs
  - src/FamilyCoordinationApp/Program.cs
autonomous: true

must_haves:
  truths:
    - "RecipeScraperService fetches HTML with realistic User-Agent headers"
    - "HTTP client uses Polly retry with exponential backoff"
    - "AngleSharp extracts JSON-LD from script tags"
  artifacts:
    - path: "src/FamilyCoordinationApp/Services/RecipeScraperService.cs"
      provides: "HTML fetching and JSON-LD extraction"
      contains: "application/ld+json"
    - path: "src/FamilyCoordinationApp/Program.cs"
      provides: "HttpClient with Polly resilience configuration"
      contains: "AddStandardResilienceHandler"
  key_links:
    - from: "RecipeScraperService"
      to: "IHttpClientFactory"
      via: "named client injection"
      pattern: "CreateClient.*RecipeScraper"
---

<objective>
Create RecipeScraperService for fetching HTML from recipe URLs with HTTP resilience and extracting JSON-LD structured data.

Purpose: Implement the core scraping capability with anti-bot mitigation (User-Agent rotation) and Polly retry policies.
Output: RecipeScraperService with FetchHtmlAsync and ExtractJsonLdAsync methods.
</objective>

<execution_context>
@/home/sirm/.claude/get-shit-done/workflows/execute-plan.md
@/home/sirm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-recipe-import/06-RESEARCH.md
@src/FamilyCoordinationApp/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure HttpClient with Polly resilience in Program.cs</name>
  <files>src/FamilyCoordinationApp/Program.cs</files>
  <action>
Add named HttpClient with Polly resilience for recipe scraping. Add near other service registrations:

```csharp
// Add using for Polly
using Microsoft.Extensions.Http.Resilience;
using System.Net;

// Add HttpClient for recipe scraping with Polly resilience
builder.Services.AddHttpClient("RecipeScraper")
    .ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler
    {
        AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate
    })
    .AddStandardResilienceHandler(options =>
    {
        options.Retry.MaxRetryAttempts = 3;
        options.Retry.BackoffType = DelayBackoffType.Exponential;
        options.Retry.UseJitter = true;
        options.AttemptTimeout.Timeout = TimeSpan.FromSeconds(30);
        options.TotalRequestTimeout.Timeout = TimeSpan.FromSeconds(60);
        options.CircuitBreaker.FailureRatio = 0.5;
        options.CircuitBreaker.SamplingDuration = TimeSpan.FromSeconds(10);
        options.CircuitBreaker.BreakDuration = TimeSpan.FromSeconds(30);
    });
```

Note: AddStandardResilienceHandler is from Microsoft.Extensions.Http.Resilience which is part of Polly 8.x ecosystem. If not available, use the Polly extension method directly:

Alternative if AddStandardResilienceHandler not found:
```csharp
using Polly;
using Polly.Extensions.Http;

builder.Services.AddHttpClient("RecipeScraper")
    .ConfigurePrimaryHttpMessageHandler(() => new HttpClientHandler
    {
        AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate
    })
    .AddPolicyHandler(
        HttpPolicyExtensions
            .HandleTransientHttpError()
            .WaitAndRetryAsync(3, retryAttempt =>
                TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) +
                TimeSpan.FromMilliseconds(Random.Shared.Next(0, 1000))))
    .AddPolicyHandler(Policy.TimeoutAsync<HttpResponseMessage>(TimeSpan.FromSeconds(30)));
```

Also add the NuGet package if needed:
```bash
dotnet add package Microsoft.Extensions.Http.Resilience --version 8.0.0
```
  </action>
  <verify>`dotnet build` passes, Program.cs contains "RecipeScraper" HttpClient configuration</verify>
  <done>Named HttpClient configured with Polly retry and timeout policies</done>
</task>

<task type="auto">
  <name>Task 2: Create RecipeScraperService with HTML fetch and JSON-LD extraction</name>
  <files>src/FamilyCoordinationApp/Services/RecipeScraperService.cs</files>
  <action>
Create RecipeScraperService.cs for fetching HTML and extracting JSON-LD:

```csharp
using System.Text.Json;
using AngleSharp.Html.Parser;
using FamilyCoordinationApp.Models.SchemaOrg;

namespace FamilyCoordinationApp.Services;

public interface IRecipeScraperService
{
    /// <summary>
    /// Fetches HTML content from URL with resilient HTTP client.
    /// </summary>
    Task<string> FetchHtmlAsync(string url, CancellationToken cancellationToken = default);

    /// <summary>
    /// Extracts RecipeSchema from JSON-LD script tags in HTML.
    /// Returns null if no Recipe JSON-LD found.
    /// </summary>
    Task<RecipeSchema?> ExtractJsonLdAsync(string html, CancellationToken cancellationToken = default);

    /// <summary>
    /// Fetches URL and extracts Recipe JSON-LD in one operation.
    /// </summary>
    Task<RecipeSchema?> ScrapeRecipeAsync(string url, CancellationToken cancellationToken = default);
}

public class RecipeScraperService : IRecipeScraperService
{
    private readonly IHttpClientFactory _httpClientFactory;
    private readonly ILogger<RecipeScraperService> _logger;
    private readonly HtmlParser _htmlParser;

    // Realistic User-Agent strings (rotate to avoid fingerprinting)
    private static readonly string[] UserAgents = new[]
    {
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:123.0) Gecko/20100101 Firefox/123.0",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Safari/605.1.15",
    };

    public RecipeScraperService(
        IHttpClientFactory httpClientFactory,
        ILogger<RecipeScraperService> logger)
    {
        _httpClientFactory = httpClientFactory;
        _logger = logger;
        _htmlParser = new HtmlParser();
    }

    public async Task<string> FetchHtmlAsync(string url, CancellationToken cancellationToken = default)
    {
        var client = _httpClientFactory.CreateClient("RecipeScraper");

        // Set realistic User-Agent (critical for anti-bot)
        var userAgent = UserAgents[Random.Shared.Next(UserAgents.Length)];
        client.DefaultRequestHeaders.Clear();
        client.DefaultRequestHeaders.Add("User-Agent", userAgent);
        client.DefaultRequestHeaders.Add("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8");
        client.DefaultRequestHeaders.Add("Accept-Language", "en-US,en;q=0.9");

        _logger.LogInformation("Fetching recipe from {Url}", url);

        var response = await client.GetAsync(url, cancellationToken);
        response.EnsureSuccessStatusCode();

        return await response.Content.ReadAsStringAsync(cancellationToken);
    }

    public async Task<RecipeSchema?> ExtractJsonLdAsync(string html, CancellationToken cancellationToken = default)
    {
        var document = await _htmlParser.ParseDocumentAsync(html, cancellationToken);

        // Query for JSON-LD script tags
        var jsonLdScripts = document.QuerySelectorAll("script[type='application/ld+json']");

        foreach (var script in jsonLdScripts)
        {
            var jsonContent = script.TextContent;
            if (string.IsNullOrWhiteSpace(jsonContent))
                continue;

            try
            {
                var recipe = TryParseRecipeFromJson(jsonContent);
                if (recipe != null)
                {
                    _logger.LogInformation("Extracted recipe '{Name}' from JSON-LD", recipe.Name);
                    return recipe;
                }
            }
            catch (JsonException ex)
            {
                _logger.LogDebug(ex, "Failed to parse JSON-LD script: {Content}", jsonContent.Substring(0, Math.Min(100, jsonContent.Length)));
                // Try next script tag
            }
        }

        _logger.LogWarning("No Recipe JSON-LD found in HTML");
        return null;
    }

    public async Task<RecipeSchema?> ScrapeRecipeAsync(string url, CancellationToken cancellationToken = default)
    {
        var html = await FetchHtmlAsync(url, cancellationToken);
        return await ExtractJsonLdAsync(html, cancellationToken);
    }

    private static RecipeSchema? TryParseRecipeFromJson(string jsonContent)
    {
        var trimmed = jsonContent.Trim();

        // Handle array format: [{...}, {...}]
        if (trimmed.StartsWith('['))
        {
            var items = JsonSerializer.Deserialize<JsonElement[]>(trimmed);
            if (items != null)
            {
                foreach (var item in items)
                {
                    var recipe = TryParseRecipeElement(item);
                    if (recipe != null)
                        return recipe;
                }
            }
            return null;
        }

        // Handle single object format: {...}
        var element = JsonSerializer.Deserialize<JsonElement>(trimmed);
        return TryParseRecipeElement(element);
    }

    private static RecipeSchema? TryParseRecipeElement(JsonElement element)
    {
        if (element.ValueKind != JsonValueKind.Object)
            return null;

        // Check @type property
        if (element.TryGetProperty("@type", out var typeProperty))
        {
            var type = typeProperty.GetString();
            if (type == "Recipe")
            {
                return JsonSerializer.Deserialize<RecipeSchema>(element.GetRawText());
            }

            // Handle @graph structure: { "@graph": [{...Recipe...}] }
            if (element.TryGetProperty("@graph", out var graphProperty) && graphProperty.ValueKind == JsonValueKind.Array)
            {
                foreach (var graphItem in graphProperty.EnumerateArray())
                {
                    var recipe = TryParseRecipeElement(graphItem);
                    if (recipe != null)
                        return recipe;
                }
            }
        }

        // Check if @graph exists without @type at root
        if (element.TryGetProperty("@graph", out var graph) && graph.ValueKind == JsonValueKind.Array)
        {
            foreach (var graphItem in graph.EnumerateArray())
            {
                var recipe = TryParseRecipeElement(graphItem);
                if (recipe != null)
                    return recipe;
            }
        }

        return null;
    }
}
```

Key features:
- User-Agent rotation from pool of 4 real browser strings
- Standard browser headers (Accept, Accept-Language)
- Handles JSON-LD as single object, array, or @graph structure
- Logs extraction progress for debugging
  </action>
  <verify>`dotnet build` passes, RecipeScraperService.cs contains FetchHtmlAsync and ExtractJsonLdAsync methods</verify>
  <done>RecipeScraperService exists with HTML fetching (User-Agent rotation) and JSON-LD extraction (AngleSharp)</done>
</task>

<task type="auto">
  <name>Task 3: Register RecipeScraperService in DI container</name>
  <files>src/FamilyCoordinationApp/Program.cs</files>
  <action>
Add RecipeScraperService registration in Program.cs with other service registrations:

```csharp
builder.Services.AddScoped<IRecipeScraperService, RecipeScraperService>();
```

Also add UrlValidator registration:

```csharp
builder.Services.AddSingleton<IUrlValidator, UrlValidator>();
```
  </action>
  <verify>`dotnet build` passes, services are registered in Program.cs</verify>
  <done>RecipeScraperService and UrlValidator registered in DI container</done>
</task>

</tasks>

<verification>
1. `dotnet build src/FamilyCoordinationApp` - No compilation errors
2. grep -q "RecipeScraper" src/FamilyCoordinationApp/Program.cs (HttpClient configured)
3. grep -q "IRecipeScraperService" src/FamilyCoordinationApp/Program.cs (service registered)
4. grep -q "application/ld+json" src/FamilyCoordinationApp/Services/RecipeScraperService.cs (JSON-LD extraction)
5. grep -q "User-Agent" src/FamilyCoordinationApp/Services/RecipeScraperService.cs (anti-bot headers)
</verification>

<success_criteria>
- HttpClient "RecipeScraper" configured with Polly retry policies
- RecipeScraperService fetches HTML with rotating User-Agent headers
- JSON-LD extraction handles array, object, and @graph formats
- Services registered in DI container
- Solution builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/06-recipe-import/06-02-SUMMARY.md`
</output>
