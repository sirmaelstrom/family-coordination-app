---
phase: 05-multi-user-collaboration
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/FamilyCoordinationApp/Services/DataNotifier.cs
  - src/FamilyCoordinationApp/Services/PresenceService.cs
  - src/FamilyCoordinationApp/Services/PollingService.cs
  - src/FamilyCoordinationApp/Program.cs
autonomous: true

must_haves:
  truths:
    - "DataNotifier broadcasts data change events to subscribed components"
    - "PresenceService tracks which users are currently online with heartbeat"
    - "PollingService runs continuously checking for data changes"
  artifacts:
    - path: "src/FamilyCoordinationApp/Services/DataNotifier.cs"
      provides: "Pub-sub event notification singleton"
      contains: "OnShoppingListChanged"
    - path: "src/FamilyCoordinationApp/Services/PresenceService.cs"
      provides: "User presence tracking with heartbeat"
      contains: "Heartbeat"
    - path: "src/FamilyCoordinationApp/Services/PollingService.cs"
      provides: "Background polling with PeriodicTimer"
      contains: "PeriodicTimer"
  key_links:
    - from: "PollingService"
      to: "DataNotifier"
      via: "Notifies on detected changes"
      pattern: "_notifier\\.Notify"
    - from: "PollingService"
      to: "PresenceService"
      via: "Updates presence timeouts"
      pattern: "_presence\\.UpdatePresence"
---

<objective>
Create the background infrastructure for multi-user collaboration: DataNotifier for pub-sub events, PresenceService for online status, and PollingService for automatic data refresh.

Purpose: Enable real-time-like collaboration through polling-based synchronization.
Output: Three singleton services registered and running.
</objective>

<execution_context>
@/home/sirm/.claude/get-shit-done/workflows/execute-plan.md
@/home/sirm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-user-collaboration/05-RESEARCH.md
@.planning/phases/05-multi-user-collaboration/05-01-SUMMARY.md
@src/FamilyCoordinationApp/Program.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DataNotifier pub-sub service</name>
  <files>src/FamilyCoordinationApp/Services/DataNotifier.cs</files>
  <action>
Create singleton service that broadcasts data change events:

```csharp
namespace FamilyCoordinationApp.Services;

/// <summary>
/// Pub-sub notification service that decouples background polling from UI updates.
/// Components subscribe to events and call InvokeAsync(StateHasChanged) in handlers.
/// </summary>
public class DataNotifier
{
    public event Action? OnRecipesChanged;
    public event Action? OnShoppingListChanged;
    public event Action? OnMealPlanChanged;
    public event Action? OnPresenceChanged;

    public void NotifyRecipesChanged() => OnRecipesChanged?.Invoke();
    public void NotifyShoppingListChanged() => OnShoppingListChanged?.Invoke();
    public void NotifyMealPlanChanged() => OnMealPlanChanged?.Invoke();
    public void NotifyPresenceChanged() => OnPresenceChanged?.Invoke();
}
```
  </action>
  <verify>File compiles, contains all four event types</verify>
  <done>DataNotifier service created with pub-sub events</done>
</task>

<task type="auto">
  <name>Task 2: Create PresenceService for online status tracking</name>
  <files>src/FamilyCoordinationApp/Services/PresenceService.cs</files>
  <action>
Create singleton service that tracks online users:

```csharp
using System.Collections.Concurrent;

namespace FamilyCoordinationApp.Services;

public enum PresenceStatus { Online, Away, Offline }

public class UserPresence
{
    public int UserId { get; set; }
    public string DisplayName { get; set; } = string.Empty;
    public string? PictureUrl { get; set; }
    public string Initials { get; set; } = string.Empty;
    public DateTime LastSeen { get; set; }
    public PresenceStatus Status { get; set; }
    public string? CurrentPage { get; set; }  // e.g., "/shopping-list"
}

public class PresenceService
{
    private readonly ConcurrentDictionary<int, UserPresence> _presence = new();
    private readonly TimeSpan _awayTimeout = TimeSpan.FromMinutes(5);
    private readonly TimeSpan _offlineTimeout = TimeSpan.FromMinutes(15);

    public event Action? OnPresenceChanged;

    /// <summary>
    /// Called by components to indicate user activity.
    /// </summary>
    public void Heartbeat(int userId, string displayName, string? pictureUrl, string initials, string? currentPage = null)
    {
        _presence.AddOrUpdate(
            userId,
            new UserPresence
            {
                UserId = userId,
                DisplayName = displayName,
                PictureUrl = pictureUrl,
                Initials = initials,
                LastSeen = DateTime.UtcNow,
                Status = PresenceStatus.Online,
                CurrentPage = currentPage
            },
            (_, existing) =>
            {
                existing.LastSeen = DateTime.UtcNow;
                existing.Status = PresenceStatus.Online;
                existing.CurrentPage = currentPage;
                existing.DisplayName = displayName;
                existing.PictureUrl = pictureUrl;
                existing.Initials = initials;
                return existing;
            });

        OnPresenceChanged?.Invoke();
    }

    /// <summary>
    /// Called by polling service to update presence states based on timeouts.
    /// </summary>
    public void UpdatePresence()
    {
        var now = DateTime.UtcNow;
        var changed = false;

        foreach (var kvp in _presence)
        {
            var timeSinceLastSeen = now - kvp.Value.LastSeen;
            var newStatus = timeSinceLastSeen switch
            {
                { TotalMinutes: > 15 } => PresenceStatus.Offline,
                { TotalMinutes: > 5 } => PresenceStatus.Away,
                _ => PresenceStatus.Online
            };

            if (kvp.Value.Status != newStatus)
            {
                kvp.Value.Status = newStatus;
                changed = true;
            }
        }

        // Remove offline users after extended period (1 hour)
        var staleUsers = _presence.Where(p => (now - p.Value.LastSeen).TotalHours > 1).Select(p => p.Key).ToList();
        foreach (var userId in staleUsers)
        {
            _presence.TryRemove(userId, out _);
            changed = true;
        }

        if (changed)
        {
            OnPresenceChanged?.Invoke();
        }
    }

    public IEnumerable<UserPresence> GetOnlineUsers() =>
        _presence.Values.Where(p => p.Status == PresenceStatus.Online);

    public IEnumerable<UserPresence> GetAllActiveUsers() =>
        _presence.Values.Where(p => p.Status != PresenceStatus.Offline);

    public IEnumerable<UserPresence> GetUsersOnPage(string page) =>
        _presence.Values.Where(p => p.Status == PresenceStatus.Online && p.CurrentPage == page);

    public UserPresence? GetUserPresence(int userId) =>
        _presence.TryGetValue(userId, out var presence) ? presence : null;

    public void UserDisconnected(int userId)
    {
        if (_presence.TryGetValue(userId, out var presence))
        {
            presence.Status = PresenceStatus.Offline;
            OnPresenceChanged?.Invoke();
        }
    }
}
```
  </action>
  <verify>File compiles, Heartbeat and UpdatePresence methods exist</verify>
  <done>PresenceService tracks online users with timeout-based status</done>
</task>

<task type="auto">
  <name>Task 3: Create PollingService background worker</name>
  <files>src/FamilyCoordinationApp/Services/PollingService.cs</files>
  <action>
Create IHostedService that polls for data changes:

```csharp
using FamilyCoordinationApp.Data;
using Microsoft.EntityFrameworkCore;

namespace FamilyCoordinationApp.Services;

/// <summary>
/// Background service that polls for data changes and notifies subscribers.
/// Uses PeriodicTimer for clean async cancellation.
/// </summary>
public class PollingService(
    IDbContextFactory<ApplicationDbContext> dbFactory,
    DataNotifier notifier,
    PresenceService presenceService,
    ILogger<PollingService> logger) : BackgroundService
{
    private DateTime _lastShoppingListCheck = DateTime.UtcNow;
    private DateTime _lastRecipeCheck = DateTime.UtcNow;
    private DateTime _lastMealPlanCheck = DateTime.UtcNow;

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        logger.LogInformation("PollingService starting with 5-second interval");

        // Use 5-second interval for responsive collaboration
        using var timer = new PeriodicTimer(TimeSpan.FromSeconds(5));

        while (await timer.WaitForNextTickAsync(stoppingToken))
        {
            try
            {
                await CheckForChangesAsync(stoppingToken);
                presenceService.UpdatePresence();
            }
            catch (OperationCanceledException)
            {
                // Expected on shutdown
                break;
            }
            catch (Exception ex)
            {
                logger.LogError(ex, "Error during polling check");
                // Continue polling even on errors
            }
        }

        logger.LogInformation("PollingService stopped");
    }

    private async Task CheckForChangesAsync(CancellationToken ct)
    {
        await using var db = await dbFactory.CreateDbContextAsync(ct);

        // Check shopping list changes
        var hasShoppingChanges = await db.ShoppingListItems
            .AnyAsync(item => item.UpdatedAt > _lastShoppingListCheck, ct);

        if (hasShoppingChanges)
        {
            logger.LogDebug("Shopping list changes detected");
            notifier.NotifyShoppingListChanged();
        }
        _lastShoppingListCheck = DateTime.UtcNow;

        // Check recipe changes
        var hasRecipeChanges = await db.Recipes
            .AnyAsync(r => r.UpdatedAt > _lastRecipeCheck && !r.IsDeleted, ct);

        if (hasRecipeChanges)
        {
            logger.LogDebug("Recipe changes detected");
            notifier.NotifyRecipesChanged();
        }
        _lastRecipeCheck = DateTime.UtcNow;

        // Check meal plan changes
        var hasMealPlanChanges = await db.MealPlanEntries
            .AnyAsync(e => e.UpdatedAt > _lastMealPlanCheck, ct);

        if (hasMealPlanChanges)
        {
            logger.LogDebug("Meal plan changes detected");
            notifier.NotifyMealPlanChanged();
        }
        _lastMealPlanCheck = DateTime.UtcNow;
    }
}
```
  </action>
  <verify>File compiles, uses PeriodicTimer, calls notifier methods</verify>
  <done>PollingService continuously checks for data changes and notifies DataNotifier</done>
</task>

<task type="auto">
  <name>Task 4: Register services in Program.cs</name>
  <files>src/FamilyCoordinationApp/Program.cs</files>
  <action>
Register the three new services in Program.cs:

After the existing scoped services section, add:

```csharp
// Collaboration services - singleton for cross-component communication
builder.Services.AddSingleton<DataNotifier>();
builder.Services.AddSingleton<PresenceService>();
builder.Services.AddHostedService<PollingService>();
```

Note: DataNotifier and PresenceService are singletons because they maintain state shared across all user connections. PollingService is a hosted service (long-running background task).
  </action>
  <verify>`dotnet build` passes, services registered in DI container</verify>
  <done>DataNotifier, PresenceService, and PollingService registered in DI</done>
</task>

</tasks>

<verification>
1. `dotnet build src/FamilyCoordinationApp` - No compilation errors
2. DataNotifier.cs exists with four event types
3. PresenceService.cs exists with Heartbeat and UpdatePresence methods
4. PollingService.cs exists with PeriodicTimer-based ExecuteAsync
5. Program.cs contains AddSingleton<DataNotifier>(), AddSingleton<PresenceService>(), AddHostedService<PollingService>()
</verification>

<success_criteria>
- DataNotifier has events for recipes, shopping list, meal plan, and presence
- PresenceService tracks users with online/away/offline status
- PollingService runs every 5 seconds checking for database changes
- All three services registered correctly in DI container
- Solution builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-user-collaboration/05-03-SUMMARY.md`
</output>
