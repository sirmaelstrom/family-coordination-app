---
phase: 02-recipe-management
plan: 04
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/FamilyCoordinationApp/Components/Recipe/IngredientEntry.razor
  - src/FamilyCoordinationApp/Components/Recipe/IngredientList.razor
  - src/FamilyCoordinationApp/Components/Recipe/BulkPasteDialog.razor
  - src/FamilyCoordinationApp/wwwroot/js/mobile-dragdrop.js
  - src/FamilyCoordinationApp/Components/App.razor
autonomous: true

must_haves:
  truths:
    - "User can type ingredient in natural language and see parsed result"
    - "User can edit parsed fields (quantity, unit, name, category, notes)"
    - "User can paste multiple ingredients at once and see parsed results"
    - "Ingredient names autocomplete from household's previous entries"
    - "User can drag to reorder ingredients"
    - "User can delete ingredient with undo toast"
  artifacts:
    - path: "src/FamilyCoordinationApp/Components/Recipe/IngredientEntry.razor"
      provides: "Ingredient entry with parsing and bulk paste"
      contains: "ParseIngredient"
    - path: "src/FamilyCoordinationApp/Components/Recipe/BulkPasteDialog.razor"
      provides: "Bulk paste modal with verification"
      contains: "MudDialog"
    - path: "src/FamilyCoordinationApp/Components/Recipe/IngredientList.razor"
      provides: "Drag-drop ingredient list"
      contains: "Dropzone"
  key_links:
    - from: "IngredientEntry.razor"
      to: "IngredientParser"
      via: "service injection"
      pattern: "IngredientParser"
    - from: "IngredientEntry.razor"
      to: "CategoryService"
      via: "service injection"
      pattern: "ICategoryService"
    - from: "IngredientList.razor"
      to: "blazor-dragdrop"
      via: "Dropzone component"
      pattern: "Plk.Blazor.DragDrop"
---

<objective>
Create ingredient entry component with natural language parsing, bulk paste support, and drag-drop reordering.

Purpose: Enable the hybrid ingredient entry experience where users type "2 cups flour" and get structured fields, or paste multiple lines for batch import.
Output: IngredientEntry component for parsing, BulkPasteDialog for multi-line import, IngredientList component for display/reorder.
</objective>

<execution_context>
@/home/[USER]/.claude/get-shit-done/workflows/execute-plan.md
@/home/[USER]/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-recipe-management/02-CONTEXT.md
@.planning/phases/02-recipe-management/02-RESEARCH.md

# Ingredient parser from Plan 02
@src/FamilyCoordinationApp/Services/IngredientParser.cs

# MudBlazor setup from Plan 01
@src/FamilyCoordinationApp/Components/_Imports.razor

# Recipe entities
@src/FamilyCoordinationApp/Data/Entities/RecipeIngredient.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add blazor-dragdrop package and mobile polyfill</name>
  <files>
    src/FamilyCoordinationApp/FamilyCoordinationApp.csproj
    src/FamilyCoordinationApp/Program.cs
    src/FamilyCoordinationApp/Components/App.razor
    src/FamilyCoordinationApp/Components/_Imports.razor
  </files>
  <action>
1. Add blazor-dragdrop package:
   ```bash
   cd src/FamilyCoordinationApp
   dotnet add package blazor-dragdrop
   ```

2. Register drag-drop services in Program.cs (before `var app = builder.Build()`):
   ```csharp
   builder.Services.AddBlazorDragDrop();
   ```

3. Add using directive to _Imports.razor:
   ```razor
   @using Plk.Blazor.DragDrop
   ```

4. Add mobile-drag-drop polyfill script to App.razor. In the `<head>` section, add:
   ```html
   <script src="https://cdn.jsdelivr.net/npm/mobile-drag-drop@2.3.0-rc.2/index.min.js"></script>
   <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mobile-drag-drop@2.3.0-rc.2/default.css" />
   ```

5. After the MudBlazor.min.js script (at end of body), add initialization:
   ```html
   <script>
       if (typeof MobileDragDrop !== 'undefined') {
           MobileDragDrop.polyfill({
               dragImageTranslateOverride: MobileDragDrop.scrollBehaviourDragImageTranslateOverride
           });
       }
   </script>
   ```
  </action>
  <verify>
    Run `dotnet build src/FamilyCoordinationApp` - should compile without errors.
  </verify>
  <done>blazor-dragdrop installed, mobile polyfill configured</done>
</task>

<task type="auto">
  <name>Task 2: Create IngredientEntry component with parsing and dynamic categories</name>
  <files>
    src/FamilyCoordinationApp/Components/Recipe/IngredientEntry.razor
  </files>
  <action>
Create the Recipe folder and IngredientEntry.razor component:

```razor
@using FamilyCoordinationApp.Services
@using FamilyCoordinationApp.Data.Entities
@using Fractions

@inject IngredientParser Parser
@inject IRecipeService RecipeService
@inject ICategoryService CategoryService

<MudPaper Class="pa-4 mb-4" Elevation="1">
    <div class="d-flex justify-space-between align-center mb-3">
        <MudText Typo="Typo.subtitle1">Add Ingredients</MudText>
        <MudButton Variant="Variant.Text"
                   Size="Size.Small"
                   StartIcon="@Icons.Material.Filled.ContentPaste"
                   OnClick="OpenBulkPaste">
            Bulk Paste
        </MudButton>
    </div>

    <MudGrid>
        <MudItem xs="12">
            <MudTextField @bind-Value="_rawInput"
                          Label="Add ingredient (e.g., '2 cups flour' or '1/2 lb chicken, boneless')"
                          Variant="Variant.Outlined"
                          Adornment="Adornment.End"
                          AdornmentIcon="@Icons.Material.Filled.Add"
                          OnAdornmentClick="AddIngredient"
                          OnKeyDown="HandleKeyDown"
                          FullWidth="true" />
        </MudItem>

        @if (_showParsed && _parsed != null)
        {
            <MudItem xs="12" sm="2">
                <MudTextField @bind-Value="_quantity"
                              Label="Quantity"
                              Variant="Variant.Outlined" />
            </MudItem>
            <MudItem xs="12" sm="2">
                <MudAutocomplete T="string"
                                 @bind-Value="_unit"
                                 Label="Unit"
                                 SearchFunc="SearchUnits"
                                 Variant="Variant.Outlined"
                                 CoerceText="false"
                                 ResetValueOnEmptyText="true" />
            </MudItem>
            <MudItem xs="12" sm="4">
                <MudAutocomplete T="string"
                                 @bind-Value="_name"
                                 Label="Ingredient"
                                 SearchFunc="SearchIngredients"
                                 Variant="Variant.Outlined"
                                 DebounceInterval="300"
                                 MinCharacters="2"
                                 CoerceText="false" />
            </MudItem>
            <MudItem xs="12" sm="2">
                <MudSelect T="string" @bind-Value="_category" Label="Category" Variant="Variant.Outlined">
                    @foreach (var cat in _categories)
                    {
                        <MudSelectItem Value="@cat.Name">@cat.Name</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>
            <MudItem xs="12" sm="2">
                <MudButton Variant="Variant.Filled"
                           Color="Color.Primary"
                           OnClick="AddIngredient"
                           FullWidth="true"
                           Style="height: 56px;">
                    Add
                </MudButton>
            </MudItem>
            <MudItem xs="12">
                <MudTextField @bind-Value="_notes"
                              Label="Notes (optional)"
                              Variant="Variant.Outlined"
                              FullWidth="true" />
            </MudItem>
        }
    </MudGrid>
</MudPaper>

@code {
    [Parameter] public int HouseholdId { get; set; }
    [Parameter] public EventCallback<RecipeIngredient> OnIngredientAdded { get; set; }
    [Parameter] public EventCallback<List<RecipeIngredient>> OnBulkIngredientsAdded { get; set; }

    private string _rawInput = string.Empty;
    private bool _showParsed = false;
    private ParsedIngredient? _parsed;

    private string _quantity = string.Empty;
    private string _unit = string.Empty;
    private string _name = string.Empty;
    private string _category = "Pantry";
    private string _notes = string.Empty;

    private List<Category> _categories = new();

    private static readonly string[] Units =
    {
        "cup", "cups", "tbsp", "tsp", "oz", "lb", "lbs", "g", "kg", "ml", "l",
        "clove", "cloves", "can", "cans", "bunch", "slice", "slices", "piece", "pieces"
    };

    protected override async Task OnInitializedAsync()
    {
        await LoadCategories();
    }

    private async Task LoadCategories()
    {
        _categories = (await CategoryService.GetCategoriesAsync(HouseholdId)).ToList();
        if (_categories.Any())
        {
            _category = _categories.First().Name;
        }
    }

    private void HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            if (_showParsed)
            {
                _ = AddIngredient();
            }
            else if (!string.IsNullOrWhiteSpace(_rawInput))
            {
                ParseInput();
            }
        }
        else if (e.Key == "Tab" && !_showParsed && !string.IsNullOrWhiteSpace(_rawInput))
        {
            ParseInput();
        }
    }

    private void ParseInput()
    {
        if (string.IsNullOrWhiteSpace(_rawInput))
            return;

        _parsed = Parser.ParseIngredient(_rawInput);
        _showParsed = true;

        // Populate fields from parsed result
        _quantity = _parsed.Quantity?.ToString() ?? string.Empty;
        _unit = _parsed.Unit ?? string.Empty;
        _name = _parsed.Name;
        _notes = _parsed.Notes ?? string.Empty;

        // Auto-suggest category based on ingredient name
        _category = SuggestCategory(_name);
    }

    private async Task AddIngredient()
    {
        if (!_showParsed)
        {
            ParseInput();
            if (!_showParsed) return;
        }

        if (string.IsNullOrWhiteSpace(_name))
            return;

        decimal? quantity = null;
        if (!string.IsNullOrWhiteSpace(_quantity) && decimal.TryParse(_quantity, out var q))
        {
            quantity = q;
        }

        var ingredient = new RecipeIngredient
        {
            Name = _name.Trim(),
            Quantity = quantity,
            Unit = string.IsNullOrWhiteSpace(_unit) ? null : _unit.Trim(),
            Category = _category,
            Notes = string.IsNullOrWhiteSpace(_notes) ? null : _notes.Trim()
        };

        await OnIngredientAdded.InvokeAsync(ingredient);

        // Reset form
        _rawInput = string.Empty;
        _showParsed = false;
        _parsed = null;
        _quantity = string.Empty;
        _unit = string.Empty;
        _name = string.Empty;
        _category = _categories.Any() ? _categories.First().Name : "Pantry";
        _notes = string.Empty;
    }

    private async Task OpenBulkPaste()
    {
        var dialog = DialogService.Show<BulkPasteDialog>("Bulk Paste Ingredients");
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is List<RecipeIngredient> ingredients)
        {
            await OnBulkIngredientsAdded.InvokeAsync(ingredients);
        }
    }

    private Task<IEnumerable<string>> SearchUnits(string value, CancellationToken token)
    {
        if (string.IsNullOrWhiteSpace(value))
            return Task.FromResult(Units.AsEnumerable());

        return Task.FromResult(Units.Where(u =>
            u.StartsWith(value, StringComparison.OrdinalIgnoreCase)).AsEnumerable());
    }

    private async Task<IEnumerable<string>> SearchIngredients(string value, CancellationToken token)
    {
        if (string.IsNullOrWhiteSpace(value) || value.Length < 2)
            return Enumerable.Empty<string>();

        return await RecipeService.GetIngredientSuggestionsAsync(HouseholdId, value, token);
    }

    private string SuggestCategory(string ingredientName)
    {
        var lower = ingredientName.ToLowerInvariant();

        // Simple heuristics - can be expanded
        if (lower.Contains("chicken") || lower.Contains("beef") || lower.Contains("pork") ||
            lower.Contains("fish") || lower.Contains("salmon") || lower.Contains("shrimp") ||
            lower.Contains("bacon") || lower.Contains("sausage") || lower.Contains("turkey"))
            return FindCategory("Meat");

        if (lower.Contains("milk") || lower.Contains("cheese") || lower.Contains("cream") ||
            lower.Contains("butter") || lower.Contains("yogurt") || lower.Contains("egg"))
            return FindCategory("Dairy");

        if (lower.Contains("lettuce") || lower.Contains("tomato") || lower.Contains("onion") ||
            lower.Contains("garlic") || lower.Contains("pepper") || lower.Contains("carrot") ||
            lower.Contains("celery") || lower.Contains("potato") || lower.Contains("broccoli") ||
            lower.Contains("spinach") || lower.Contains("cucumber") || lower.Contains("avocado"))
            return FindCategory("Produce");

        if (lower.Contains("salt") || lower.Contains("pepper") || lower.Contains("cumin") ||
            lower.Contains("paprika") || lower.Contains("oregano") || lower.Contains("basil") ||
            lower.Contains("thyme") || lower.Contains("rosemary") || lower.Contains("cinnamon"))
            return FindCategory("Spices");

        if (lower.Contains("bread") || lower.Contains("bun") || lower.Contains("roll") ||
            lower.Contains("tortilla") || lower.Contains("bagel"))
            return FindCategory("Bakery");

        if (lower.Contains("frozen"))
            return FindCategory("Frozen");

        return FindCategory("Pantry");
    }

    private string FindCategory(string name)
    {
        var category = _categories.FirstOrDefault(c => c.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
        return category?.Name ?? (_categories.Any() ? _categories.First().Name : "Pantry");
    }
}
```
  </action>
  <verify>
    Run `dotnet build src/FamilyCoordinationApp` - should compile without errors.
  </verify>
  <done>IngredientEntry component created with parsing, autocomplete, dynamic categories, and bulk paste button</done>
</task>

<task type="auto">
  <name>Task 3: Create BulkPasteDialog for multi-line ingredient entry</name>
  <files>
    src/FamilyCoordinationApp/Components/Recipe/BulkPasteDialog.razor
  </files>
  <action>
Create BulkPasteDialog.razor component:

```razor
@using FamilyCoordinationApp.Services
@using FamilyCoordinationApp.Data.Entities

@inject IngredientParser Parser
@inject ICategoryService CategoryService

<MudDialog>
    <DialogContent>
        <MudText Typo="Typo.body1" Class="mb-3">
            Paste multiple ingredients (one per line). Each line will be parsed into structured fields.
        </MudText>

        <MudTextField @bind-Value="_pastedText"
                      Label="Paste ingredients here"
                      Variant="Variant.Outlined"
                      Lines="10"
                      Immediate="true"
                      FullWidth="true"
                      Class="mb-4" />

        @if (_parsedIngredients.Any())
        {
            <MudText Typo="Typo.subtitle2" Class="mb-2">
                Parsed Ingredients (@_parsedIngredients.Count)
            </MudText>

            <MudPaper Elevation="0" Class="pa-3" Style="max-height: 400px; overflow-y: auto; background-color: var(--mud-palette-background-grey);">
                @foreach (var (line, parsed, index) in _parsedIngredients.Select((x, i) => (x.Line, x.Parsed, i)))
                {
                    <MudPaper Class="pa-2 mb-2" Elevation="1">
                        <MudGrid>
                            <MudItem xs="12" Class="d-flex justify-space-between align-center">
                                <MudText Typo="Typo.caption" Color="Color.Secondary">
                                    Original: @line
                                </MudText>
                                <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                               Size="Size.Small"
                                               Color="Color.Error"
                                               OnClick="() => RemoveParsedIngredient(index)" />
                            </MudItem>
                            <MudItem xs="3">
                                <MudText Typo="Typo.body2">
                                    <strong>Qty:</strong> @(parsed.Quantity?.ToString() ?? "—")
                                </MudText>
                            </MudItem>
                            <MudItem xs="3">
                                <MudText Typo="Typo.body2">
                                    <strong>Unit:</strong> @(parsed.Unit ?? "—")
                                </MudText>
                            </MudItem>
                            <MudItem xs="6">
                                <MudText Typo="Typo.body2">
                                    <strong>Name:</strong> @parsed.Name
                                </MudText>
                            </MudItem>
                            @if (!string.IsNullOrWhiteSpace(parsed.Notes))
                            {
                                <MudItem xs="12">
                                    <MudText Typo="Typo.caption">
                                        <strong>Notes:</strong> @parsed.Notes
                                    </MudText>
                                </MudItem>
                            }
                            @if (!parsed.IsComplete)
                            {
                                <MudItem xs="12">
                                    <MudAlert Severity="Severity.Warning" Dense="true">
                                        Incomplete parse - review and edit after import
                                    </MudAlert>
                                </MudItem>
                            }
                        </MudGrid>
                    </MudPaper>
                }
            </MudPaper>
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="Cancel">Cancel</MudButton>
        <MudButton Color="Color.Primary"
                   Variant="Variant.Filled"
                   OnClick="ImportIngredients"
                   Disabled="!_parsedIngredients.Any()">
            Import @_parsedIngredients.Count Ingredient@(_parsedIngredients.Count != 1 ? "s" : "")
        </MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter] MudDialogInstance MudDialog { get; set; } = default!;
    [Parameter] public int HouseholdId { get; set; }

    private string _pastedText = string.Empty;
    private List<(string Line, ParsedIngredient Parsed)> _parsedIngredients = new();
    private List<Category> _categories = new();

    protected override async Task OnInitializedAsync()
    {
        _categories = (await CategoryService.GetCategoriesAsync(HouseholdId)).ToList();
    }

    protected override void OnParametersSet()
    {
        // Watch for changes to pasted text
        if (!string.IsNullOrWhiteSpace(_pastedText))
        {
            ParsePastedText();
        }
        else
        {
            _parsedIngredients.Clear();
        }
    }

    private void ParsePastedText()
    {
        var lines = _pastedText
            .Split(new[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries)
            .Select(l => l.Trim())
            .Where(l => !string.IsNullOrWhiteSpace(l))
            .ToList();

        _parsedIngredients = lines
            .Select(line => (Line: line, Parsed: Parser.ParseIngredient(line)))
            .ToList();
    }

    private void RemoveParsedIngredient(int index)
    {
        if (index >= 0 && index < _parsedIngredients.Count)
        {
            _parsedIngredients.RemoveAt(index);
        }
    }

    private void Cancel()
    {
        MudDialog.Cancel();
    }

    private void ImportIngredients()
    {
        var ingredients = _parsedIngredients.Select((item, index) => new RecipeIngredient
        {
            Name = item.Parsed.Name,
            Quantity = item.Parsed.Quantity,
            Unit = item.Parsed.Unit,
            Category = SuggestCategory(item.Parsed.Name),
            Notes = item.Parsed.Notes,
            SortOrder = index
        }).ToList();

        MudDialog.Close(DialogResult.Ok(ingredients));
    }

    private string SuggestCategory(string ingredientName)
    {
        var lower = ingredientName.ToLowerInvariant();

        if (lower.Contains("chicken") || lower.Contains("beef") || lower.Contains("pork") ||
            lower.Contains("fish") || lower.Contains("salmon") || lower.Contains("shrimp") ||
            lower.Contains("bacon") || lower.Contains("sausage") || lower.Contains("turkey"))
            return FindCategory("Meat");

        if (lower.Contains("milk") || lower.Contains("cheese") || lower.Contains("cream") ||
            lower.Contains("butter") || lower.Contains("yogurt") || lower.Contains("egg"))
            return FindCategory("Dairy");

        if (lower.Contains("lettuce") || lower.Contains("tomato") || lower.Contains("onion") ||
            lower.Contains("garlic") || lower.Contains("pepper") || lower.Contains("carrot") ||
            lower.Contains("celery") || lower.Contains("potato") || lower.Contains("broccoli") ||
            lower.Contains("spinach") || lower.Contains("cucumber") || lower.Contains("avocado"))
            return FindCategory("Produce");

        if (lower.Contains("salt") || lower.Contains("pepper") || lower.Contains("cumin") ||
            lower.Contains("paprika") || lower.Contains("oregano") || lower.Contains("basil") ||
            lower.Contains("thyme") || lower.Contains("rosemary") || lower.Contains("cinnamon"))
            return FindCategory("Spices");

        if (lower.Contains("bread") || lower.Contains("bun") || lower.Contains("roll") ||
            lower.Contains("tortilla") || lower.Contains("bagel"))
            return FindCategory("Bakery");

        if (lower.Contains("frozen"))
            return FindCategory("Frozen");

        return FindCategory("Pantry");
    }

    private string FindCategory(string name)
    {
        var category = _categories.FirstOrDefault(c => c.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
        return category?.Name ?? (_categories.Any() ? _categories.First().Name : "Pantry");
    }
}
```
  </action>
  <verify>
    Run `dotnet build src/FamilyCoordinationApp` - should compile without errors.
  </verify>
  <done>BulkPasteDialog component created with multi-line parsing and verification view</done>
</task>

<task type="auto">
  <name>Task 4: Create IngredientList component with drag-drop and undo</name>
  <files>
    src/FamilyCoordinationApp/Components/Recipe/IngredientList.razor
  </files>
  <action>
Create IngredientList.razor component with drag-drop reordering:

```razor
@using FamilyCoordinationApp.Data.Entities
@using Plk.Blazor.DragDrop

@inject ISnackbar Snackbar

<MudText Typo="Typo.subtitle1" Class="mb-2">
    Ingredients (@Ingredients.Count)
</MudText>

@if (Ingredients.Count == 0)
{
    <MudAlert Severity="Severity.Info" Class="mb-4">
        No ingredients yet. Use the form above to add ingredients.
    </MudAlert>
}
else
{
    <Dropzone Items="Ingredients"
              InstantReplace="true"
              TItem="RecipeIngredient"
              Class="ingredient-dropzone">
        @foreach (var ingredient in context)
        {
            <MudPaper Class="pa-3 mb-2 d-flex align-center justify-space-between ingredient-item"
                      Elevation="1"
                      Style="cursor: grab;">
                <div class="d-flex align-center">
                    <MudIcon Icon="@Icons.Material.Filled.DragIndicator"
                             Class="mr-2"
                             Color="Color.Default"
                             Size="Size.Small" />
                    <div>
                        <MudText Typo="Typo.body1">
                            @FormatIngredient(ingredient)
                        </MudText>
                        @if (!string.IsNullOrWhiteSpace(ingredient.Notes))
                        {
                            <MudText Typo="Typo.caption" Color="Color.Secondary">
                                @ingredient.Notes
                            </MudText>
                        }
                    </div>
                </div>
                <div class="d-flex align-center">
                    <MudChip T="string" Size="Size.Small" Color="@GetCategoryColor(ingredient.Category)">
                        @ingredient.Category
                    </MudChip>
                    <MudIconButton Icon="@Icons.Material.Filled.Edit"
                                   Size="Size.Small"
                                   OnClick="() => EditIngredient(ingredient)"
                                   Class="ml-2" />
                    <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                   Size="Size.Small"
                                   Color="Color.Error"
                                   OnClick="() => DeleteIngredient(ingredient)" />
                </div>
            </MudPaper>
        }
    </Dropzone>
}

<style>
    .ingredient-dropzone {
        min-height: 100px;
    }
    .ingredient-item:hover {
        background-color: var(--mud-palette-action-default-hover);
    }
</style>

@code {
    [Parameter] public List<RecipeIngredient> Ingredients { get; set; } = new();
    [Parameter] public EventCallback<List<RecipeIngredient>> IngredientsChanged { get; set; }
    [Parameter] public EventCallback<RecipeIngredient> OnEditIngredient { get; set; }

    private RecipeIngredient? _deletedIngredient;
    private int _deletedIndex;

    private string FormatIngredient(RecipeIngredient ing)
    {
        var parts = new List<string>();

        if (ing.Quantity.HasValue)
        {
            // Display as fraction if applicable
            var qty = ing.Quantity.Value;
            parts.Add(FormatQuantity(qty));
        }

        if (!string.IsNullOrWhiteSpace(ing.Unit))
        {
            parts.Add(ing.Unit);
        }

        parts.Add(ing.Name);

        return string.Join(" ", parts);
    }

    private static string FormatQuantity(decimal qty)
    {
        // Common fractions
        if (qty == 0.25m) return "1/4";
        if (qty == 0.5m) return "1/2";
        if (qty == 0.75m) return "3/4";
        if (qty == 0.33m || qty == (1m/3m)) return "1/3";
        if (qty == 0.67m || qty == (2m/3m)) return "2/3";

        // Mixed fractions
        var whole = Math.Truncate(qty);
        var frac = qty - whole;

        if (frac == 0) return whole.ToString("0.##");

        if (whole > 0)
        {
            if (frac == 0.25m) return $"{whole:0} 1/4";
            if (frac == 0.5m) return $"{whole:0} 1/2";
            if (frac == 0.75m) return $"{whole:0} 3/4";
            if (frac == 0.33m || Math.Abs(frac - (1m/3m)) < 0.01m) return $"{whole:0} 1/3";
            if (frac == 0.67m || Math.Abs(frac - (2m/3m)) < 0.01m) return $"{whole:0} 2/3";
        }

        // Decimal fallback
        return qty.ToString("0.##");
    }

    private Color GetCategoryColor(string category)
    {
        return category switch
        {
            "Meat" => Color.Error,
            "Produce" => Color.Success,
            "Dairy" => Color.Warning,
            "Pantry" => Color.Default,
            "Spices" => Color.Secondary,
            "Frozen" => Color.Info,
            "Bakery" => Color.Tertiary,
            "Beverages" => Color.Primary,
            _ => Color.Default
        };
    }

    private async Task EditIngredient(RecipeIngredient ingredient)
    {
        await OnEditIngredient.InvokeAsync(ingredient);
    }

    private async Task DeleteIngredient(RecipeIngredient ingredient)
    {
        _deletedIngredient = ingredient;
        _deletedIndex = Ingredients.IndexOf(ingredient);

        Ingredients.Remove(ingredient);
        UpdateSortOrder();
        await IngredientsChanged.InvokeAsync(Ingredients);

        Snackbar.Add("Ingredient deleted", Severity.Normal, config =>
        {
            config.Action = "Undo";
            config.ActionColor = Color.Primary;
            config.Onclick = async _ => await UndoDelete();
            config.VisibleStateDuration = 5000;
        });
    }

    private async Task UndoDelete()
    {
        if (_deletedIngredient != null)
        {
            // Insert back at original position
            if (_deletedIndex >= 0 && _deletedIndex <= Ingredients.Count)
            {
                Ingredients.Insert(_deletedIndex, _deletedIngredient);
            }
            else
            {
                Ingredients.Add(_deletedIngredient);
            }

            UpdateSortOrder();
            await IngredientsChanged.InvokeAsync(Ingredients);

            Snackbar.Add("Ingredient restored", Severity.Success);

            _deletedIngredient = null;
        }
    }

    private void UpdateSortOrder()
    {
        for (int i = 0; i < Ingredients.Count; i++)
        {
            Ingredients[i].SortOrder = i;
        }
    }
}
```
  </action>
  <verify>
    Run `dotnet build src/FamilyCoordinationApp` - should compile without errors.
  </verify>
  <done>IngredientList component created with drag-drop reordering, delete with undo toast</done>
</task>

</tasks>

<verification>
1. `dotnet build src/FamilyCoordinationApp` compiles without errors
2. blazor-dragdrop package installed
3. IngredientEntry.razor exists with parsing, autocomplete, dynamic categories, and bulk paste button
4. BulkPasteDialog.razor exists with multi-line parsing and verification
5. IngredientList.razor exists with drag-drop and undo delete
6. Mobile drag-drop polyfill script added to App.razor
</verification>

<success_criteria>
- User types natural language ingredient and sees parsed structured fields
- Parsed fields (quantity, unit, name, category, notes) are editable
- User can click "Bulk Paste" to open dialog for multi-line ingredient entry
- Bulk paste shows original text alongside parsed results
- Parse failures highlighted with warning in bulk paste dialog
- Ingredient name autocompletes from household's previous entries
- Categories loaded dynamically from CategoryService (not hardcoded)
- Category auto-suggested based on ingredient name
- Ingredients can be reordered via drag-drop
- Delete shows undo toast for 5 seconds
- Undo restores ingredient to original position
</success_criteria>

<output>
After completion, create `.planning/phases/02-recipe-management/02-04-SUMMARY.md`
</output>
