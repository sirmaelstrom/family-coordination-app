@using FamilyCoordinationApp.Data.Entities
@using Plk.Blazor.DragDrop

<MudPaper Class="mb-4" Elevation="2">
    <div class="category-header" @onclick="ToggleExpanded">
        <MudText Typo="Typo.h6">@Category</MudText>
        <div class="d-flex align-center gap-2">
            <MudChip T="string" Size="Size.Small" Color="Color.Default" Text="@GetUncheckedCount().ToString()" />
            <MudIcon Icon="@GetExpandIcon()" Size="Size.Small" />
        </div>
    </div>

    @if (_expanded)
    {
        <div class="category-body">
            @foreach (var item in Items)
            {
                <ShoppingListItemRow Item="@item"
                                     OnChecked="@OnItemChecked"
                                     OnEdit="@OnItemEdit"
                                     OnDelete="@OnItemDelete" />
            }
        </div>
    }
</MudPaper>

@code {
    [Parameter] public string Category { get; set; } = default!;
    [Parameter] public List<ShoppingListItem> Items { get; set; } = new();
    [Parameter] public EventCallback OnReorder { get; set; }
    [Parameter] public EventCallback<ShoppingListItem> OnItemChecked { get; set; }
    [Parameter] public EventCallback<ShoppingListItem> OnItemEdit { get; set; }
    [Parameter] public EventCallback<ShoppingListItem> OnItemDelete { get; set; }

    private bool _expanded = true;

    private void ToggleExpanded()
    {
        _expanded = !_expanded;
    }

    private string GetExpandIcon()
    {
        return _expanded ? Icons.Material.Filled.ExpandLess : Icons.Material.Filled.ExpandMore;
    }

    private int GetUncheckedCount()
    {
        return Items.Count(i => !i.IsChecked);
    }

    private bool AllowsDrag(ShoppingListItem item)
    {
        // Can't drag checked items
        return !item.IsChecked;
    }

    private async Task HandleItemDrop()
    {
        // blazor-dragdrop modifies Items list in place
        // Update SortOrder for all items in category
        for (int i = 0; i < Items.Count; i++)
        {
            Items[i].SortOrder = i;
        }

        // Signal parent to persist the reordering
        await OnReorder.InvokeAsync();
    }
}

<style>
    .category-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    .category-header:hover {
        background-color: var(--mud-palette-action-default-hover);
    }

    .category-body {
        padding-bottom: 8px;
    }
</style>
