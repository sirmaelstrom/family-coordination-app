---
phase: 02-recipe-management
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/FamilyCoordinationApp/Services/ImageService.cs
  - src/FamilyCoordinationApp/Services/RecipeService.cs
  - src/FamilyCoordinationApp/Program.cs
autonomous: true

must_haves:
  truths:
    - "User can upload recipe image up to 10 MB"
    - "Uploaded images are saved to wwwroot/uploads/{householdId}/"
    - "Recipe CRUD operations work with household isolation"
    - "Soft delete marks recipe as deleted without removing data"
  artifacts:
    - path: "src/FamilyCoordinationApp/Services/ImageService.cs"
      provides: "Image upload and storage service"
      contains: "SaveImageAsync"
    - path: "src/FamilyCoordinationApp/Services/RecipeService.cs"
      provides: "Recipe CRUD operations"
      contains: "CreateRecipeAsync"
  key_links:
    - from: "ImageService"
      to: "filesystem"
      via: "FileStream write"
      pattern: "FileStream"
    - from: "RecipeService"
      to: "ApplicationDbContext"
      via: "DbContextFactory"
      pattern: "CreateDbContext"
---

<objective>
Create ImageService for file uploads and RecipeService for recipe CRUD operations with household isolation.

Purpose: Provide backend services for recipe management UI components.
Output: ImageService with streaming file uploads, RecipeService with Create/Read/Update/Delete operations.
</objective>

<execution_context>
@/home/[USER]/.claude/get-shit-done/workflows/execute-plan.md
@/home/[USER]/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-recipe-management/02-CONTEXT.md
@.planning/phases/02-recipe-management/02-RESEARCH.md

# Phase 1 established DbContextFactory pattern
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md

# Existing entities
@src/FamilyCoordinationApp/Data/Entities/Recipe.cs
@src/FamilyCoordinationApp/Data/Entities/RecipeIngredient.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ImageService for file upload streaming</name>
  <files>
    src/FamilyCoordinationApp/Services/ImageService.cs
    src/FamilyCoordinationApp/Program.cs
  </files>
  <action>
1. Create ImageService.cs:
```csharp
using Microsoft.AspNetCore.Components.Forms;

namespace FamilyCoordinationApp.Services;

public interface IImageService
{
    Task<string> SaveImageAsync(IBrowserFile file, int householdId, CancellationToken cancellationToken = default);
    Task DeleteImageAsync(string imagePath, CancellationToken cancellationToken = default);
    string GetImageUrl(string? imagePath);
}

public class ImageService : IImageService
{
    private readonly IWebHostEnvironment _environment;
    private readonly ILogger<ImageService> _logger;
    private const long MaxFileSize = 10 * 1024 * 1024; // 10 MB

    private static readonly HashSet<string> AllowedExtensions = new(StringComparer.OrdinalIgnoreCase)
    {
        ".jpg", ".jpeg", ".png", ".gif", ".webp"
    };

    private static readonly HashSet<string> AllowedContentTypes = new(StringComparer.OrdinalIgnoreCase)
    {
        "image/jpeg", "image/png", "image/gif", "image/webp"
    };

    public ImageService(IWebHostEnvironment environment, ILogger<ImageService> logger)
    {
        _environment = environment;
        _logger = logger;
    }

    public async Task<string> SaveImageAsync(IBrowserFile file, int householdId, CancellationToken cancellationToken = default)
    {
        // Validate file
        if (file.Size > MaxFileSize)
        {
            throw new InvalidOperationException($"File size exceeds maximum allowed size of {MaxFileSize / 1024 / 1024} MB.");
        }

        var extension = Path.GetExtension(file.Name);
        if (!AllowedExtensions.Contains(extension))
        {
            throw new InvalidOperationException($"File type '{extension}' is not allowed. Allowed types: {string.Join(", ", AllowedExtensions)}");
        }

        if (!AllowedContentTypes.Contains(file.ContentType))
        {
            throw new InvalidOperationException($"Content type '{file.ContentType}' is not allowed.");
        }

        // Generate unique filename
        var trustedFileName = $"{Guid.NewGuid()}{extension}";
        var uploadsPath = Path.Combine(_environment.WebRootPath, "uploads", householdId.ToString());

        // Ensure directory exists
        Directory.CreateDirectory(uploadsPath);

        var filePath = Path.Combine(uploadsPath, trustedFileName);

        // Stream file directly to filesystem (not into memory)
        try
        {
            await using var stream = file.OpenReadStream(MaxFileSize, cancellationToken);
            await using var fs = new FileStream(filePath, FileMode.Create);
            await stream.CopyToAsync(fs, cancellationToken);

            _logger.LogInformation("Saved image {FileName} for household {HouseholdId}", trustedFileName, householdId);

            // Return relative URL path
            return $"/uploads/{householdId}/{trustedFileName}";
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to save image for household {HouseholdId}", householdId);

            // Clean up partial file if it exists
            if (File.Exists(filePath))
            {
                try { File.Delete(filePath); } catch { /* ignore cleanup errors */ }
            }

            throw;
        }
    }

    public Task DeleteImageAsync(string imagePath, CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(imagePath))
            return Task.CompletedTask;

        // Convert URL path to filesystem path
        // imagePath format: /uploads/{householdId}/{filename}
        var relativePath = imagePath.TrimStart('/');
        var fullPath = Path.Combine(_environment.WebRootPath, relativePath);

        if (File.Exists(fullPath))
        {
            try
            {
                File.Delete(fullPath);
                _logger.LogInformation("Deleted image at {Path}", imagePath);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to delete image at {Path}", imagePath);
                // Don't throw - image deletion is not critical
            }
        }

        return Task.CompletedTask;
    }

    public string GetImageUrl(string? imagePath)
    {
        if (string.IsNullOrWhiteSpace(imagePath))
        {
            // Return placeholder based on recipe type (handled in component)
            return string.Empty;
        }

        return imagePath;
    }
}
```

2. Register ImageService in Program.cs (add before `var app = builder.Build()`):
```csharp
builder.Services.AddScoped<IImageService, ImageService>();
```

3. Ensure wwwroot/uploads directory exists or will be created dynamically (handled in SaveImageAsync).
  </action>
  <verify>
    Run `dotnet build src/FamilyCoordinationApp` - should compile without errors.
  </verify>
  <done>ImageService created with streaming file upload, registered in DI</done>
</task>

<task type="auto">
  <name>Task 2: Create RecipeService for CRUD operations</name>
  <files>
    src/FamilyCoordinationApp/Services/RecipeService.cs
    src/FamilyCoordinationApp/Program.cs
  </files>
  <action>
Create RecipeService.cs with household-isolated CRUD operations:

```csharp
using Microsoft.EntityFrameworkCore;
using FamilyCoordinationApp.Data;
using FamilyCoordinationApp.Data.Entities;

namespace FamilyCoordinationApp.Services;

public interface IRecipeService
{
    Task<List<Recipe>> GetRecipesAsync(int householdId, string? searchTerm = null, CancellationToken cancellationToken = default);
    Task<Recipe?> GetRecipeAsync(int householdId, int recipeId, CancellationToken cancellationToken = default);
    Task<Recipe> CreateRecipeAsync(Recipe recipe, CancellationToken cancellationToken = default);
    Task<Recipe> UpdateRecipeAsync(Recipe recipe, CancellationToken cancellationToken = default);
    Task DeleteRecipeAsync(int householdId, int recipeId, CancellationToken cancellationToken = default);
    Task<int> GetNextRecipeIdAsync(int householdId, CancellationToken cancellationToken = default);
    Task<List<string>> GetIngredientSuggestionsAsync(int householdId, string prefix, CancellationToken cancellationToken = default);
}

public class RecipeService : IRecipeService
{
    private readonly IDbContextFactory<ApplicationDbContext> _dbFactory;
    private readonly ILogger<RecipeService> _logger;

    public RecipeService(IDbContextFactory<ApplicationDbContext> dbFactory, ILogger<RecipeService> logger)
    {
        _dbFactory = dbFactory;
        _logger = logger;
    }

    public async Task<List<Recipe>> GetRecipesAsync(int householdId, string? searchTerm = null, CancellationToken cancellationToken = default)
    {
        await using var context = await _dbFactory.CreateDbContextAsync(cancellationToken);

        var query = context.Recipes
            .Where(r => r.HouseholdId == householdId)
            .Include(r => r.Ingredients.OrderBy(i => i.SortOrder))
            .AsQueryable();

        if (!string.IsNullOrWhiteSpace(searchTerm))
        {
            var term = searchTerm.Trim().ToLower();
            query = query.Where(r => r.Name.ToLower().Contains(term));
        }

        return await query
            .OrderBy(r => r.Name)
            .ToListAsync(cancellationToken);
    }

    public async Task<Recipe?> GetRecipeAsync(int householdId, int recipeId, CancellationToken cancellationToken = default)
    {
        await using var context = await _dbFactory.CreateDbContextAsync(cancellationToken);

        return await context.Recipes
            .Where(r => r.HouseholdId == householdId && r.RecipeId == recipeId)
            .Include(r => r.Ingredients.OrderBy(i => i.SortOrder))
            .Include(r => r.CreatedBy)
            .FirstOrDefaultAsync(cancellationToken);
    }

    public async Task<Recipe> CreateRecipeAsync(Recipe recipe, CancellationToken cancellationToken = default)
    {
        await using var context = await _dbFactory.CreateDbContextAsync(cancellationToken);

        // Get next recipe ID for this household
        recipe.RecipeId = await GetNextRecipeIdInternalAsync(context, recipe.HouseholdId, cancellationToken);
        recipe.CreatedAt = DateTime.UtcNow;

        // Set ingredient IDs and household IDs
        var ingredientId = 1;
        foreach (var ingredient in recipe.Ingredients)
        {
            ingredient.HouseholdId = recipe.HouseholdId;
            ingredient.RecipeId = recipe.RecipeId;
            ingredient.IngredientId = ingredientId++;
        }

        context.Recipes.Add(recipe);
        await context.SaveChangesAsync(cancellationToken);

        _logger.LogInformation("Created recipe {RecipeId} for household {HouseholdId}", recipe.RecipeId, recipe.HouseholdId);

        return recipe;
    }

    public async Task<Recipe> UpdateRecipeAsync(Recipe recipe, CancellationToken cancellationToken = default)
    {
        await using var context = await _dbFactory.CreateDbContextAsync(cancellationToken);

        // Load existing recipe with ingredients
        var existing = await context.Recipes
            .Include(r => r.Ingredients)
            .FirstOrDefaultAsync(r => r.HouseholdId == recipe.HouseholdId && r.RecipeId == recipe.RecipeId, cancellationToken);

        if (existing == null)
        {
            throw new InvalidOperationException($"Recipe {recipe.RecipeId} not found in household {recipe.HouseholdId}");
        }

        // Update scalar properties
        existing.Name = recipe.Name;
        existing.Description = recipe.Description;
        existing.Instructions = recipe.Instructions;
        existing.ImagePath = recipe.ImagePath;
        existing.SourceUrl = recipe.SourceUrl;
        existing.Servings = recipe.Servings;
        existing.PrepTimeMinutes = recipe.PrepTimeMinutes;
        existing.CookTimeMinutes = recipe.CookTimeMinutes;
        existing.UpdatedAt = DateTime.UtcNow;

        // Replace ingredients (simpler than tracking changes)
        context.RecipeIngredients.RemoveRange(existing.Ingredients);

        var ingredientId = 1;
        foreach (var ingredient in recipe.Ingredients)
        {
            var newIngredient = new RecipeIngredient
            {
                HouseholdId = recipe.HouseholdId,
                RecipeId = recipe.RecipeId,
                IngredientId = ingredientId++,
                Name = ingredient.Name,
                Quantity = ingredient.Quantity,
                Unit = ingredient.Unit,
                Category = ingredient.Category,
                Notes = ingredient.Notes,
                GroupName = ingredient.GroupName,
                SortOrder = ingredient.SortOrder
            };
            context.RecipeIngredients.Add(newIngredient);
        }

        await context.SaveChangesAsync(cancellationToken);

        _logger.LogInformation("Updated recipe {RecipeId} for household {HouseholdId}", recipe.RecipeId, recipe.HouseholdId);

        return existing;
    }

    public async Task DeleteRecipeAsync(int householdId, int recipeId, CancellationToken cancellationToken = default)
    {
        await using var context = await _dbFactory.CreateDbContextAsync(cancellationToken);

        var recipe = await context.Recipes
            .FirstOrDefaultAsync(r => r.HouseholdId == householdId && r.RecipeId == recipeId, cancellationToken);

        if (recipe == null)
        {
            throw new InvalidOperationException($"Recipe {recipeId} not found in household {householdId}");
        }

        // Soft delete
        recipe.IsDeleted = true;

        await context.SaveChangesAsync(cancellationToken);

        _logger.LogInformation("Soft deleted recipe {RecipeId} for household {HouseholdId}", recipeId, householdId);
    }

    public async Task<int> GetNextRecipeIdAsync(int householdId, CancellationToken cancellationToken = default)
    {
        await using var context = await _dbFactory.CreateDbContextAsync(cancellationToken);
        return await GetNextRecipeIdInternalAsync(context, householdId, cancellationToken);
    }

    private static async Task<int> GetNextRecipeIdInternalAsync(ApplicationDbContext context, int householdId, CancellationToken cancellationToken)
    {
        var maxId = await context.Recipes
            .IgnoreQueryFilters() // Include soft-deleted
            .Where(r => r.HouseholdId == householdId)
            .MaxAsync(r => (int?)r.RecipeId, cancellationToken) ?? 0;

        return maxId + 1;
    }

    public async Task<List<string>> GetIngredientSuggestionsAsync(int householdId, string prefix, CancellationToken cancellationToken = default)
    {
        if (string.IsNullOrWhiteSpace(prefix) || prefix.Length < 2)
            return new List<string>();

        await using var context = await _dbFactory.CreateDbContextAsync(cancellationToken);

        return await context.RecipeIngredients
            .Where(i => i.HouseholdId == householdId && i.Name.StartsWith(prefix))
            .Select(i => i.Name)
            .Distinct()
            .Take(20)
            .ToListAsync(cancellationToken);
    }
}
```

Register in Program.cs (add near other service registrations):
```csharp
builder.Services.AddScoped<IRecipeService, RecipeService>();
```
  </action>
  <verify>
    Run `dotnet build src/FamilyCoordinationApp` - should compile without errors.
  </verify>
  <done>RecipeService created with CRUD operations and ingredient suggestions, registered in DI</done>
</task>

<task type="auto">
  <name>Task 3: Add soft delete query filter for Recipe entity</name>
  <files>
    src/FamilyCoordinationApp/Data/Configurations/RecipeConfiguration.cs
  </files>
  <action>
Update RecipeConfiguration.cs to add global query filter for soft delete:

1. Open the file and add inside the Configure method:
```csharp
builder.HasQueryFilter(r => !r.IsDeleted);
```

This ensures soft-deleted recipes are automatically excluded from queries unless `.IgnoreQueryFilters()` is used.

Also add an index on Name for search performance:
```csharp
builder.HasIndex(r => new { r.HouseholdId, r.Name });
```
  </action>
  <verify>
    Run `dotnet build src/FamilyCoordinationApp` - should compile without errors.
  </verify>
  <done>Recipe soft delete query filter and search index added</done>
</task>

</tasks>

<verification>
1. `dotnet build src/FamilyCoordinationApp` compiles without errors
2. ImageService.cs exists with SaveImageAsync, DeleteImageAsync, GetImageUrl methods
3. RecipeService.cs exists with GetRecipesAsync, GetRecipeAsync, CreateRecipeAsync, UpdateRecipeAsync, DeleteRecipeAsync methods
4. Both services registered in Program.cs
5. Recipe entity has global query filter for soft delete
</verification>

<success_criteria>
- ImageService streams files directly to filesystem (no MemoryStream)
- ImageService validates file size (10 MB max) and content type
- RecipeService provides household-isolated CRUD operations
- RecipeService supports search by recipe name
- Soft delete marks IsDeleted=true without removing data
- Query filter automatically excludes soft-deleted recipes
- Ingredient suggestions support autocomplete with StartsWith for index usage
</success_criteria>

<output>
After completion, create `.planning/phases/02-recipe-management/02-03-SUMMARY.md`
</output>
