---
phase: 02-recipe-management
plan: 07
type: execute
wave: 4
depends_on: ["02-05", "02-06"]
files_modified:
  - src/FamilyCoordinationApp/Components/Pages/Settings/Categories.razor
  - src/FamilyCoordinationApp/Services/CategoryService.cs
  - src/FamilyCoordinationApp/Program.cs
  - src/FamilyCoordinationApp/Components/Layout/NavMenu.razor
autonomous: false

must_haves:
  truths:
    - "User can view list of ingredient categories"
    - "User can add custom category"
    - "User can edit category name, color, and emoji"
    - "User can reorder categories"
    - "User can soft-delete category (with restore option)"
    - "Recipe CRUD workflow functions end-to-end"
  artifacts:
    - path: "src/FamilyCoordinationApp/Components/Pages/Settings/Categories.razor"
      provides: "Category management page"
      contains: "CategoryService"
    - path: "src/FamilyCoordinationApp/Services/CategoryService.cs"
      provides: "Category CRUD service"
      contains: "CreateCategoryAsync"
  key_links:
    - from: "Categories.razor"
      to: "CategoryService"
      via: "service injection"
      pattern: "CategoryService"
---

<objective>
Create category management settings page and verify complete recipe CRUD workflow.

Purpose: Allow users to customize ingredient categories and verify all recipe management features work together.
Output: Categories settings page, CategoryService, human verification of complete workflow.
</objective>

<execution_context>
@/home/[USER]/.claude/get-shit-done/workflows/execute-plan.md
@/home/[USER]/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/02-recipe-management/02-CONTEXT.md

# Category entity from Plan 01
@src/FamilyCoordinationApp/Data/Entities/Category.cs

# Recipe pages from Plans 05 and 06
@src/FamilyCoordinationApp/Components/Pages/Recipes.razor
@src/FamilyCoordinationApp/Components/Pages/RecipeEdit.razor
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CategoryService for CRUD operations</name>
  <files>
    src/FamilyCoordinationApp/Services/CategoryService.cs
    src/FamilyCoordinationApp/Program.cs
  </files>
  <action>
1. Create CategoryService.cs:
```csharp
using Microsoft.EntityFrameworkCore;
using FamilyCoordinationApp.Data;
using FamilyCoordinationApp.Data.Entities;

namespace FamilyCoordinationApp.Services;

public interface ICategoryService
{
    Task<List<Category>> GetCategoriesAsync(int householdId, bool includeDeleted = false, CancellationToken cancellationToken = default);
    Task<Category?> GetCategoryAsync(int householdId, int categoryId, CancellationToken cancellationToken = default);
    Task<Category> CreateCategoryAsync(Category category, CancellationToken cancellationToken = default);
    Task<Category> UpdateCategoryAsync(Category category, CancellationToken cancellationToken = default);
    Task DeleteCategoryAsync(int householdId, int categoryId, CancellationToken cancellationToken = default);
    Task RestoreCategoryAsync(int householdId, int categoryId, CancellationToken cancellationToken = default);
    Task UpdateSortOrderAsync(int householdId, List<(int CategoryId, int SortOrder)> sortOrders, CancellationToken cancellationToken = default);
    Task<int> GetNextCategoryIdAsync(int householdId, CancellationToken cancellationToken = default);
    Task<bool> HasIngredientsAsync(int householdId, string categoryName, CancellationToken cancellationToken = default);
}

public class CategoryService : ICategoryService
{
    private readonly IDbContextFactory<ApplicationDbContext> _dbFactory;
    private readonly ILogger<CategoryService> _logger;

    public CategoryService(IDbContextFactory<ApplicationDbContext> dbFactory, ILogger<CategoryService> logger)
    {
        _dbFactory = dbFactory;
        _logger = logger;
    }

    public async Task<List<Category>> GetCategoriesAsync(int householdId, bool includeDeleted = false, CancellationToken cancellationToken = default)
    {
        await using var context = await _dbFactory.CreateDbContextAsync(cancellationToken);

        var query = context.Categories
            .Where(c => c.HouseholdId == householdId);

        if (includeDeleted)
        {
            query = query.IgnoreQueryFilters();
        }

        return await query
            .OrderBy(c => c.SortOrder)
            .ToListAsync(cancellationToken);
    }

    public async Task<Category?> GetCategoryAsync(int householdId, int categoryId, CancellationToken cancellationToken = default)
    {
        await using var context = await _dbFactory.CreateDbContextAsync(cancellationToken);

        return await context.Categories
            .IgnoreQueryFilters()
            .FirstOrDefaultAsync(c => c.HouseholdId == householdId && c.CategoryId == categoryId, cancellationToken);
    }

    public async Task<Category> CreateCategoryAsync(Category category, CancellationToken cancellationToken = default)
    {
        await using var context = await _dbFactory.CreateDbContextAsync(cancellationToken);

        category.CategoryId = await GetNextCategoryIdInternalAsync(context, category.HouseholdId, cancellationToken);

        // Set sort order to end of list if not specified
        if (category.SortOrder == 0)
        {
            var maxOrder = await context.Categories
                .Where(c => c.HouseholdId == category.HouseholdId)
                .MaxAsync(c => (int?)c.SortOrder, cancellationToken) ?? 0;
            category.SortOrder = maxOrder + 1;
        }

        context.Categories.Add(category);
        await context.SaveChangesAsync(cancellationToken);

        _logger.LogInformation("Created category {CategoryId} for household {HouseholdId}", category.CategoryId, category.HouseholdId);

        return category;
    }

    public async Task<Category> UpdateCategoryAsync(Category category, CancellationToken cancellationToken = default)
    {
        await using var context = await _dbFactory.CreateDbContextAsync(cancellationToken);

        var existing = await context.Categories
            .IgnoreQueryFilters()
            .FirstOrDefaultAsync(c => c.HouseholdId == category.HouseholdId && c.CategoryId == category.CategoryId, cancellationToken);

        if (existing == null)
        {
            throw new InvalidOperationException($"Category {category.CategoryId} not found");
        }

        existing.Name = category.Name;
        existing.IconEmoji = category.IconEmoji;
        existing.Color = category.Color;
        existing.SortOrder = category.SortOrder;

        await context.SaveChangesAsync(cancellationToken);

        _logger.LogInformation("Updated category {CategoryId} for household {HouseholdId}", category.CategoryId, category.HouseholdId);

        return existing;
    }

    public async Task DeleteCategoryAsync(int householdId, int categoryId, CancellationToken cancellationToken = default)
    {
        await using var context = await _dbFactory.CreateDbContextAsync(cancellationToken);

        var category = await context.Categories
            .FirstOrDefaultAsync(c => c.HouseholdId == householdId && c.CategoryId == categoryId, cancellationToken);

        if (category == null)
        {
            throw new InvalidOperationException($"Category {categoryId} not found");
        }

        // Soft delete
        category.IsDeleted = true;
        category.DeletedAt = DateTime.UtcNow;

        await context.SaveChangesAsync(cancellationToken);

        _logger.LogInformation("Soft deleted category {CategoryId} for household {HouseholdId}", categoryId, householdId);
    }

    public async Task RestoreCategoryAsync(int householdId, int categoryId, CancellationToken cancellationToken = default)
    {
        await using var context = await _dbFactory.CreateDbContextAsync(cancellationToken);

        var category = await context.Categories
            .IgnoreQueryFilters()
            .FirstOrDefaultAsync(c => c.HouseholdId == householdId && c.CategoryId == categoryId && c.IsDeleted, cancellationToken);

        if (category == null)
        {
            throw new InvalidOperationException($"Deleted category {categoryId} not found");
        }

        category.IsDeleted = false;
        category.DeletedAt = null;

        await context.SaveChangesAsync(cancellationToken);

        _logger.LogInformation("Restored category {CategoryId} for household {HouseholdId}", categoryId, householdId);
    }

    public async Task UpdateSortOrderAsync(int householdId, List<(int CategoryId, int SortOrder)> sortOrders, CancellationToken cancellationToken = default)
    {
        await using var context = await _dbFactory.CreateDbContextAsync(cancellationToken);

        foreach (var (categoryId, sortOrder) in sortOrders)
        {
            var category = await context.Categories
                .FirstOrDefaultAsync(c => c.HouseholdId == householdId && c.CategoryId == categoryId, cancellationToken);

            if (category != null)
            {
                category.SortOrder = sortOrder;
            }
        }

        await context.SaveChangesAsync(cancellationToken);
    }

    public async Task<int> GetNextCategoryIdAsync(int householdId, CancellationToken cancellationToken = default)
    {
        await using var context = await _dbFactory.CreateDbContextAsync(cancellationToken);
        return await GetNextCategoryIdInternalAsync(context, householdId, cancellationToken);
    }

    private static async Task<int> GetNextCategoryIdInternalAsync(ApplicationDbContext context, int householdId, CancellationToken cancellationToken)
    {
        var maxId = await context.Categories
            .IgnoreQueryFilters()
            .Where(c => c.HouseholdId == householdId)
            .MaxAsync(c => (int?)c.CategoryId, cancellationToken) ?? 0;

        return maxId + 1;
    }

    public async Task<bool> HasIngredientsAsync(int householdId, string categoryName, CancellationToken cancellationToken = default)
    {
        await using var context = await _dbFactory.CreateDbContextAsync(cancellationToken);

        return await context.RecipeIngredients
            .AnyAsync(i => i.HouseholdId == householdId && i.Category == categoryName, cancellationToken);
    }
}
```

2. Register CategoryService in Program.cs:
```csharp
builder.Services.AddScoped<ICategoryService, CategoryService>();
```
  </action>
  <verify>
    Run `dotnet build src/FamilyCoordinationApp` - should compile without errors.
  </verify>
  <done>CategoryService created with CRUD and soft delete operations</done>
</task>

<task type="auto">
  <name>Task 2: Create Categories settings page</name>
  <files>
    src/FamilyCoordinationApp/Components/Pages/Settings/Categories.razor
    src/FamilyCoordinationApp/Components/Layout/NavMenu.razor
  </files>
  <action>
1. Create Categories.razor page:
```razor
@page "/settings/categories"
@attribute [Authorize]

@using FamilyCoordinationApp.Data
@using FamilyCoordinationApp.Data.Entities
@using FamilyCoordinationApp.Services
@using Microsoft.EntityFrameworkCore
@using System.Security.Claims
@using Plk.Blazor.DragDrop

@inject ICategoryService CategoryService
@inject IDbContextFactory<ApplicationDbContext> DbFactory
@inject ISnackbar Snackbar
@inject IDialogService DialogService

<PageTitle>Manage Categories - Family Coordination</PageTitle>

<MudContainer MaxWidth="MaxWidth.Medium" Class="mt-4">
    <MudText Typo="Typo.h4" Class="mb-4">Manage Categories</MudText>

    <MudText Typo="Typo.body1" Color="Color.Secondary" Class="mb-4">
        Customize ingredient categories for your household. Drag to reorder categories to match your store layout.
    </MudText>

    @if (_loading)
    {
        <MudProgressLinear Indeterminate="true" />
    }
    else
    {
        <MudPaper Class="pa-4 mb-4" Elevation="1">
            <MudText Typo="Typo.h6" Class="mb-3">Add New Category</MudText>

            <MudGrid>
                <MudItem xs="12" sm="4">
                    <MudTextField @bind-Value="_newCategory.Name"
                                  Label="Name"
                                  Variant="Variant.Outlined"
                                  Required="true" />
                </MudItem>
                <MudItem xs="12" sm="3">
                    <MudTextField @bind-Value="_newCategory.IconEmoji"
                                  Label="Emoji"
                                  Variant="Variant.Outlined"
                                  HelperText="e.g., meat_on_bone" />
                </MudItem>
                <MudItem xs="12" sm="3">
                    <MudColorPicker @bind-Text="_newCategory.Color"
                                    Label="Color"
                                    Variant="Variant.Outlined"
                                    DisableToolbar="true" />
                </MudItem>
                <MudItem xs="12" sm="2">
                    <MudButton Variant="Variant.Filled"
                               Color="Color.Primary"
                               OnClick="AddCategory"
                               FullWidth="true"
                               Style="height: 56px;">
                        Add
                    </MudButton>
                </MudItem>
            </MudGrid>
        </MudPaper>

        <MudPaper Class="pa-4 mb-4" Elevation="1">
            <MudText Typo="Typo.h6" Class="mb-3">Active Categories</MudText>

            <Dropzone Items="_categories"
                      InstantReplace="true"
                      TItem="Category"
                      OnItemDrop="OnCategoryReordered">
                @foreach (var category in context)
                {
                    <MudPaper Class="pa-3 mb-2 d-flex align-center justify-space-between"
                              Elevation="1"
                              Style="cursor: grab;">
                        <div class="d-flex align-center">
                            <MudIcon Icon="@Icons.Material.Filled.DragIndicator"
                                     Class="mr-2"
                                     Size="Size.Small" />
                            <div style="width: 24px; height: 24px; border-radius: 4px; background-color: @category.Color; margin-right: 12px;"></div>
                            <MudText>@category.Name</MudText>
                            @if (category.IsDefault)
                            {
                                <MudChip T="string" Size="Size.Small" Color="Color.Info" Class="ml-2">Default</MudChip>
                            }
                        </div>
                        <div>
                            <MudIconButton Icon="@Icons.Material.Filled.Edit"
                                           Size="Size.Small"
                                           OnClick="() => EditCategory(category)" />
                            <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                           Size="Size.Small"
                                           Color="Color.Error"
                                           OnClick="() => DeleteCategory(category)" />
                        </div>
                    </MudPaper>
                }
            </Dropzone>
        </MudPaper>

        @if (_deletedCategories.Count > 0)
        {
            <MudPaper Class="pa-4" Elevation="1">
                <MudText Typo="Typo.h6" Class="mb-3">Deleted Categories</MudText>

                @foreach (var category in _deletedCategories)
                {
                    <MudPaper Class="pa-3 mb-2 d-flex align-center justify-space-between"
                              Elevation="0"
                              Style="opacity: 0.6;">
                        <div class="d-flex align-center">
                            <div style="width: 24px; height: 24px; border-radius: 4px; background-color: @category.Color; margin-right: 12px;"></div>
                            <MudText>@category.Name</MudText>
                            <MudText Typo="Typo.caption" Color="Color.Secondary" Class="ml-2">
                                (deleted @category.DeletedAt?.ToString("MMM d"))
                            </MudText>
                        </div>
                        <MudButton Variant="Variant.Text"
                                   Color="Color.Primary"
                                   OnClick="() => RestoreCategory(category)">
                            Restore
                        </MudButton>
                    </MudPaper>
                }
            </MudPaper>
        }
    }
</MudContainer>

@code {
    [CascadingParameter] private Task<AuthenticationState>? AuthState { get; set; }

    private List<Category> _categories = new();
    private List<Category> _deletedCategories = new();
    private Category _newCategory = new() { Color = "#808080" };
    private bool _loading = true;
    private int _householdId;

    protected override async Task OnInitializedAsync()
    {
        await LoadHouseholdId();
        await LoadCategories();
        _loading = false;
    }

    private async Task LoadHouseholdId()
    {
        if (AuthState == null) return;

        var authState = await AuthState;
        var email = authState.User.FindFirstValue(ClaimTypes.Email);

        if (string.IsNullOrEmpty(email)) return;

        await using var context = await DbFactory.CreateDbContextAsync();
        var user = await context.Users
            .FirstOrDefaultAsync(u => u.Email == email);

        if (user != null)
        {
            _householdId = user.HouseholdId;
        }
    }

    private async Task LoadCategories()
    {
        var allCategories = await CategoryService.GetCategoriesAsync(_householdId, includeDeleted: true);
        _categories = allCategories.Where(c => !c.IsDeleted).OrderBy(c => c.SortOrder).ToList();
        _deletedCategories = allCategories.Where(c => c.IsDeleted).ToList();
    }

    private async Task AddCategory()
    {
        if (string.IsNullOrWhiteSpace(_newCategory.Name))
        {
            Snackbar.Add("Category name is required", Severity.Warning);
            return;
        }

        try
        {
            _newCategory.HouseholdId = _householdId;
            _newCategory.IsDefault = false;
            await CategoryService.CreateCategoryAsync(_newCategory);
            Snackbar.Add($"Category \"{_newCategory.Name}\" created", Severity.Success);

            _newCategory = new Category { Color = "#808080" };
            await LoadCategories();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to create category: {ex.Message}", Severity.Error);
        }
    }

    private async Task EditCategory(Category category)
    {
        var parameters = new DialogParameters<CategoryEditDialog>
        {
            { x => x.Category, category }
        };

        var dialog = await DialogService.ShowAsync<CategoryEditDialog>("Edit Category", parameters);
        var result = await dialog.Result;

        if (!result!.Canceled && result.Data is Category updated)
        {
            try
            {
                await CategoryService.UpdateCategoryAsync(updated);
                Snackbar.Add("Category updated", Severity.Success);
                await LoadCategories();
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Failed to update category: {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task DeleteCategory(Category category)
    {
        // Check if category has ingredients
        if (await CategoryService.HasIngredientsAsync(_householdId, category.Name))
        {
            var result = await DialogService.ShowMessageBox(
                "Category In Use",
                $"The category \"{category.Name}\" is used by ingredients in your recipes. You can still delete it, but those ingredients will keep their category assignment.",
                yesText: "Delete Anyway",
                cancelText: "Cancel");

            if (result != true) return;
        }

        try
        {
            await CategoryService.DeleteCategoryAsync(_householdId, category.CategoryId);
            Snackbar.Add($"Category \"{category.Name}\" deleted", Severity.Success);
            await LoadCategories();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to delete category: {ex.Message}", Severity.Error);
        }
    }

    private async Task RestoreCategory(Category category)
    {
        try
        {
            await CategoryService.RestoreCategoryAsync(_householdId, category.CategoryId);
            Snackbar.Add($"Category \"{category.Name}\" restored", Severity.Success);
            await LoadCategories();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to restore category: {ex.Message}", Severity.Error);
        }
    }

    private async Task OnCategoryReordered(Category item)
    {
        var sortOrders = _categories
            .Select((c, i) => (c.CategoryId, SortOrder: i))
            .ToList();

        try
        {
            await CategoryService.UpdateSortOrderAsync(_householdId, sortOrders);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to update order: {ex.Message}", Severity.Error);
            await LoadCategories(); // Reload to restore original order
        }
    }
}
```

2. Create a simple edit dialog component (CategoryEditDialog.razor) in the same folder:
```razor
@using FamilyCoordinationApp.Data.Entities

<MudDialog>
    <DialogContent>
        <MudTextField @bind-Value="Category.Name"
                      Label="Name"
                      Variant="Variant.Outlined"
                      Class="mb-3" />
        <MudTextField @bind-Value="Category.IconEmoji"
                      Label="Emoji"
                      Variant="Variant.Outlined"
                      Class="mb-3" />
        <MudColorPicker @bind-Text="Category.Color"
                        Label="Color"
                        Variant="Variant.Outlined"
                        DisableToolbar="true" />
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="Cancel">Cancel</MudButton>
        <MudButton Color="Color.Primary" OnClick="Save">Save</MudButton>
    </DialogActions>
</MudDialog>

@code {
    [CascadingParameter] private IMudDialogInstance MudDialog { get; set; } = default!;
    [Parameter] public Category Category { get; set; } = new();

    private void Cancel() => MudDialog.Cancel();
    private void Save() => MudDialog.Close(DialogResult.Ok(Category));
}
```

3. Add Settings link to NavMenu.razor:
```razor
<MudNavLink Href="/settings/categories" Match="NavLinkMatch.Prefix" Icon="@Icons.Material.Filled.Settings">
    Settings
</MudNavLink>
```
  </action>
  <verify>
    Run `dotnet build src/FamilyCoordinationApp` - should compile without errors.
  </verify>
  <done>Categories settings page created with CRUD, reorder, and restore functionality</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete recipe management workflow</name>
  <what-built>
    Complete Phase 2 recipe management:
    - MudBlazor UI with dark mode
    - Recipe list page with card grid and search
    - Recipe create/edit form with auto-save
    - Ingredient parsing and entry
    - Drag-drop ingredient reordering
    - Image upload
    - Category management settings
  </what-built>
  <how-to-verify>
    1. Start the application (ensure Docker is running for PostgreSQL):
       ```bash
       cd src/FamilyCoordinationApp
       dotnet run
       ```

    2. Navigate to https://localhost:7777 (or configured URL)

    3. Log in with Google OAuth

    4. Test Recipe List (empty state):
       - Go to /recipes
       - Verify empty state message appears
       - Verify "Add Your First Recipe" button is visible

    5. Test Recipe Creation:
       - Click "Add Recipe" or the empty state button
       - Fill in recipe name: "Test Pasta"
       - Add description, prep time (15), cook time (30), servings (4)
       - Try uploading an image (verify it appears)
       - Add ingredients using natural language:
         - Type "2 cups flour" and press Tab/Enter
         - Verify it parses to quantity=2, unit=cups, name=flour
         - Add more: "1/2 lb chicken, boneless" (should extract notes)
         - Add: "3 eggs" (unitless)
       - Drag to reorder ingredients
       - Add instructions in markdown format
       - Wait 2 seconds - verify "Draft saved" appears
       - Click "Create Recipe"
       - Verify redirect to /recipes with new recipe card

    6. Test Recipe Card Expansion:
       - Click recipe card to expand
       - Verify full details show (prep time, cook time, ingredients, instructions)
       - Verify Edit and Delete buttons visible
       - Click again to collapse

    7. Test Recipe Editing:
       - Click Edit on expanded card
       - Modify recipe name
       - Wait for auto-save
       - Click "Save Changes"
       - Verify changes persist

    8. Test Search:
       - Add a second recipe with different name
       - Use search box to filter
       - Verify only matching recipes show

    9. Test Delete:
       - Expand recipe, click Delete
       - Verify confirmation dialog
       - Confirm delete
       - Verify recipe removed from list

    10. Test Category Management:
        - Go to /settings/categories
        - Verify default categories (Meat, Produce, etc.)
        - Add custom category "Beverages"
        - Drag to reorder
        - Delete a category
        - Restore deleted category

    11. Test Draft Recovery:
        - Start new recipe, enter some data
        - Navigate away (confirm warning)
        - Return to /recipes/new
        - Verify draft is restored

    Expected: All tests pass. Recipe CRUD works end-to-end. Dark mode styling looks correct.
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. `dotnet build src/FamilyCoordinationApp` compiles without errors
2. CategoryService exists with CRUD operations
3. Categories.razor settings page exists
4. CategoryEditDialog.razor exists
5. Settings link in navigation
6. Human verification of complete workflow passes
</verification>

<success_criteria>
- Category settings page at /settings/categories
- Add, edit, delete, restore categories
- Drag to reorder categories
- Default categories cannot be permanently deleted
- Categories with ingredients show warning before delete
- Complete recipe CRUD workflow verified by human
- Dark mode styling correct
- All Phase 2 requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-recipe-management/02-07-SUMMARY.md`
</output>
