---
phase: 06-recipe-import
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/FamilyCoordinationApp/FamilyCoordinationApp.csproj
  - src/FamilyCoordinationApp/Models/SchemaOrg/RecipeSchema.cs
  - src/FamilyCoordinationApp/Services/UrlValidator.cs
autonomous: true

must_haves:
  truths:
    - "AngleSharp and Polly packages are installed"
    - "RecipeSchema POCO deserializes schema.org Recipe JSON-LD"
    - "UrlValidator blocks localhost, private IPs, and non-http(s) schemes"
  artifacts:
    - path: "src/FamilyCoordinationApp/FamilyCoordinationApp.csproj"
      provides: "AngleSharp and Polly package references"
      contains: "AngleSharp"
    - path: "src/FamilyCoordinationApp/Models/SchemaOrg/RecipeSchema.cs"
      provides: "POCO for schema.org Recipe type with JsonPropertyName attributes"
      contains: "@type"
    - path: "src/FamilyCoordinationApp/Services/UrlValidator.cs"
      provides: "SSRF protection via DNS resolution and IP range checking"
      contains: "IsPrivateOrLocalAddress"
  key_links:
    - from: "RecipeSchema"
      to: "System.Text.Json"
      via: "JsonPropertyName attributes"
      pattern: "JsonPropertyName"
---

<objective>
Set up recipe import infrastructure: add NuGet packages, create schema.org Recipe POCO, and implement URL validation for SSRF protection.

Purpose: Establish foundation for recipe scraping with proper security measures and data deserialization.
Output: Package references, RecipeSchema model, and UrlValidator service.
</objective>

<execution_context>
@/home/[USER]/.claude/get-shit-done/workflows/execute-plan.md
@/home/[USER]/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-recipe-import/06-RESEARCH.md
@src/FamilyCoordinationApp/FamilyCoordinationApp.csproj
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add AngleSharp and Polly NuGet packages</name>
  <files>src/FamilyCoordinationApp/FamilyCoordinationApp.csproj</files>
  <action>
Add NuGet package references for recipe scraping:

```bash
cd src/FamilyCoordinationApp
dotnet add package AngleSharp --version 1.4.0
dotnet add package Polly --version 8.6.5
```

These provide:
- AngleSharp 1.4.0: HTML parsing with CSS selectors (W3C-compliant DOM API)
- Polly 8.6.5: HTTP resilience (retry with exponential backoff, circuit breaker)
  </action>
  <verify>`dotnet restore` completes, csproj contains AngleSharp and Polly package references</verify>
  <done>AngleSharp 1.4.0 and Polly 8.6.5 packages installed</done>
</task>

<task type="auto">
  <name>Task 2: Create RecipeSchema POCO for schema.org deserialization</name>
  <files>src/FamilyCoordinationApp/Models/SchemaOrg/RecipeSchema.cs</files>
  <action>
Create Models/SchemaOrg directory and RecipeSchema.cs POCO for deserializing schema.org JSON-LD:

```csharp
using System.Text.Json.Serialization;

namespace FamilyCoordinationApp.Models.SchemaOrg;

/// <summary>
/// POCO for schema.org Recipe type (https://schema.org/Recipe).
/// Used to deserialize JSON-LD from recipe websites.
/// </summary>
public class RecipeSchema
{
    [JsonPropertyName("@context")]
    public string? Context { get; set; }

    [JsonPropertyName("@type")]
    public string Type { get; set; } = "Recipe";

    [JsonPropertyName("name")]
    public string? Name { get; set; }

    [JsonPropertyName("image")]
    public object? Image { get; set; } // Can be string URL or ImageObject

    [JsonPropertyName("description")]
    public string? Description { get; set; }

    [JsonPropertyName("recipeIngredient")]
    public string[]? RecipeIngredient { get; set; }

    [JsonPropertyName("recipeInstructions")]
    public object? RecipeInstructions { get; set; } // Can be string or HowToStep[]

    [JsonPropertyName("prepTime")]
    public string? PrepTime { get; set; } // ISO 8601 duration: "PT15M"

    [JsonPropertyName("cookTime")]
    public string? CookTime { get; set; } // ISO 8601 duration: "PT30M"

    [JsonPropertyName("recipeYield")]
    public object? RecipeYield { get; set; } // Can be string "4 servings" or number

    [JsonPropertyName("recipeCategory")]
    public string? RecipeCategory { get; set; }

    [JsonPropertyName("recipeCuisine")]
    public string? RecipeCuisine { get; set; }

    [JsonPropertyName("author")]
    public object? Author { get; set; } // Can be string or Person object
}

/// <summary>
/// HowToStep for structured recipe instructions.
/// </summary>
public class HowToStep
{
    [JsonPropertyName("@type")]
    public string Type { get; set; } = "HowToStep";

    [JsonPropertyName("text")]
    public string? Text { get; set; }

    [JsonPropertyName("name")]
    public string? Name { get; set; }
}
```

Note: Using `object?` for polymorphic fields (image, recipeInstructions, recipeYield, author) because schema.org allows multiple formats. The parser service will handle type detection.
  </action>
  <verify>File compiles, `dotnet build` passes</verify>
  <done>RecipeSchema POCO exists with JsonPropertyName attributes for JSON-LD deserialization</done>
</task>

<task type="auto">
  <name>Task 3: Create UrlValidator service for SSRF protection</name>
  <files>src/FamilyCoordinationApp/Services/UrlValidator.cs</files>
  <action>
Create UrlValidator.cs to validate URLs before HTTP requests, preventing SSRF attacks:

```csharp
using System.Net;
using System.Net.Sockets;

namespace FamilyCoordinationApp.Services;

public interface IUrlValidator
{
    /// <summary>
    /// Validates URL is safe to fetch (not localhost, private IP, or non-http(s) scheme).
    /// </summary>
    bool IsUrlSafe(string url);

    /// <summary>
    /// Validates URL and returns error message if invalid.
    /// </summary>
    (bool IsValid, string? ErrorMessage) ValidateUrl(string url);
}

public class UrlValidator : IUrlValidator
{
    private static readonly HashSet<string> AllowedSchemes = new(StringComparer.OrdinalIgnoreCase) { "http", "https" };

    public bool IsUrlSafe(string url)
    {
        return ValidateUrl(url).IsValid;
    }

    public (bool IsValid, string? ErrorMessage) ValidateUrl(string url)
    {
        if (string.IsNullOrWhiteSpace(url))
            return (false, "URL cannot be empty");

        if (!Uri.TryCreate(url, UriKind.Absolute, out var uri))
            return (false, "Invalid URL format");

        // Only allow http/https
        if (!AllowedSchemes.Contains(uri.Scheme))
            return (false, $"URL scheme '{uri.Scheme}' is not allowed. Use http or https.");

        // Resolve DNS to check IP addresses
        try
        {
            var addresses = Dns.GetHostAddresses(uri.Host);
            foreach (var addr in addresses)
            {
                if (IsPrivateOrLocalAddress(addr))
                    return (false, "URLs pointing to internal networks are not allowed");
            }
        }
        catch (SocketException)
        {
            return (false, "Could not resolve hostname");
        }

        return (true, null);
    }

    private static bool IsPrivateOrLocalAddress(IPAddress address)
    {
        // Loopback (127.0.0.0/8, ::1)
        if (IPAddress.IsLoopback(address))
            return true;

        // 0.0.0.0 or ::
        if (address.Equals(IPAddress.Any) || address.Equals(IPAddress.IPv6Any))
            return true;

        byte[] bytes = address.GetAddressBytes();

        if (address.AddressFamily == AddressFamily.InterNetwork)
        {
            // 10.0.0.0/8
            if (bytes[0] == 10)
                return true;

            // 172.16.0.0/12
            if (bytes[0] == 172 && bytes[1] >= 16 && bytes[1] <= 31)
                return true;

            // 192.168.0.0/16
            if (bytes[0] == 192 && bytes[1] == 168)
                return true;

            // 169.254.0.0/16 (link-local, includes AWS metadata endpoint)
            if (bytes[0] == 169 && bytes[1] == 254)
                return true;
        }

        return false;
    }
}
```

This prevents:
- Non-http(s) schemes (file://, ftp://, gopher://)
- Loopback addresses (127.0.0.1, localhost, ::1)
- Private network ranges (10.x.x.x, 172.16-31.x.x, 192.168.x.x)
- Link-local addresses (169.254.x.x - includes AWS metadata endpoint)
  </action>
  <verify>File compiles, `dotnet build` passes</verify>
  <done>UrlValidator service exists with SSRF protection via DNS resolution and IP range checking</done>
</task>

</tasks>

<verification>
1. `dotnet build src/FamilyCoordinationApp` - No compilation errors
2. grep -q "AngleSharp" src/FamilyCoordinationApp/FamilyCoordinationApp.csproj (package installed)
3. grep -q "Polly" src/FamilyCoordinationApp/FamilyCoordinationApp.csproj (package installed)
4. Test file exists: src/FamilyCoordinationApp/Models/SchemaOrg/RecipeSchema.cs
5. Test file exists: src/FamilyCoordinationApp/Services/UrlValidator.cs
</verification>

<success_criteria>
- AngleSharp 1.4.0 and Polly 8.6.5 packages are installed
- RecipeSchema POCO exists with all schema.org Recipe properties
- UrlValidator service blocks localhost, private IPs, and non-http(s) schemes
- Solution builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/06-recipe-import/06-01-SUMMARY.md`
</output>
