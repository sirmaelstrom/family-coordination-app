---
phase: 05-multi-user-collaboration
plan: 07
type: execute
wave: 5
depends_on: ["05-01", "05-06"]
files_modified:
  - src/FamilyCoordinationApp/Services/ShoppingListService.cs
  - src/FamilyCoordinationApp/Components/ShoppingList/ConflictIndicator.razor
autonomous: false

must_haves:
  truths:
    - "ShoppingListService handles DbUpdateConcurrencyException with retry"
    - "Shopping item check-off uses 'checked wins' merge strategy"
    - "Concurrency conflicts on edits show visual indicator to user"
  artifacts:
    - path: "src/FamilyCoordinationApp/Services/ShoppingListService.cs"
      provides: "Optimistic concurrency handling with smart merge"
      contains: "DbUpdateConcurrencyException"
    - path: "src/FamilyCoordinationApp/Components/ShoppingList/ConflictIndicator.razor"
      provides: "Visual indicator for conflicted items"
      contains: "conflict"
  key_links:
    - from: "ShoppingListService.UpdateItemAsync"
      to: "DbUpdateConcurrencyException handler"
      via: "try-catch with retry loop"
      pattern: "catch.*DbUpdateConcurrencyException"
---

<objective>
Implement optimistic concurrency handling for shopping list operations with "checked wins" strategy and conflict indication.

Purpose: Multiple family members can check off items simultaneously without data loss.
Output: Robust concurrency handling with user-friendly conflict display.
</objective>

<execution_context>
@/home/sirm/.claude/get-shit-done/workflows/execute-plan.md
@/home/sirm/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-user-collaboration/05-RESEARCH.md
@.planning/phases/05-multi-user-collaboration/05-01-SUMMARY.md
@.planning/phases/05-multi-user-collaboration/05-06-SUMMARY.md
@src/FamilyCoordinationApp/Services/ShoppingListService.cs
@src/FamilyCoordinationApp/Data/Entities/ShoppingListItem.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement "checked wins" concurrency handling in ShoppingListService</name>
  <files>src/FamilyCoordinationApp/Services/ShoppingListService.cs</files>
  <action>
Add using statement:
```csharp
using Microsoft.EntityFrameworkCore.ChangeTracking;
```

Create a new method for updating items with concurrency handling:

```csharp
/// <summary>
/// Updates a shopping list item with optimistic concurrency handling.
/// Uses "checked wins" strategy: if either user checked the item, it stays checked.
/// </summary>
/// <returns>True if update succeeded, false if item was deleted by another user</returns>
public async Task<(bool Success, bool WasConflict, string? ConflictMessage)> UpdateItemWithConcurrencyAsync(ShoppingListItem item)
{
    const int maxRetries = 3;
    var retries = 0;
    var wasConflict = false;
    string? conflictMessage = null;

    while (retries < maxRetries)
    {
        try
        {
            await using var context = await _dbFactory.CreateDbContextAsync();

            // Attach the item to this context
            context.ShoppingListItems.Attach(item);
            context.Entry(item).State = EntityState.Modified;

            // Set tracking fields
            item.UpdatedAt = DateTime.UtcNow;

            await context.SaveChangesAsync();
            return (true, wasConflict, conflictMessage);
        }
        catch (DbUpdateConcurrencyException ex)
        {
            retries++;
            wasConflict = true;

            foreach (var entry in ex.Entries)
            {
                if (entry.Entity is ShoppingListItem conflictedItem)
                {
                    var databaseValues = await entry.GetDatabaseValuesAsync();

                    if (databaseValues == null)
                    {
                        // Item was deleted by another user
                        return (false, true, "This item was deleted by another family member");
                    }

                    var proposedChecked = (bool)entry.CurrentValues[nameof(ShoppingListItem.IsChecked)];
                    var databaseChecked = (bool)databaseValues[nameof(ShoppingListItem.IsChecked)];

                    // "Checked wins" - if either user checked it, keep it checked
                    if (proposedChecked || databaseChecked)
                    {
                        entry.CurrentValues[nameof(ShoppingListItem.IsChecked)] = true;
                        entry.CurrentValues[nameof(ShoppingListItem.CheckedAt)] =
                            entry.CurrentValues[nameof(ShoppingListItem.CheckedAt)] ??
                            databaseValues[nameof(ShoppingListItem.CheckedAt)] ??
                            DateTime.UtcNow;
                    }

                    // For quantity/name changes, check if there's a true conflict
                    var proposedName = (string)entry.CurrentValues[nameof(ShoppingListItem.Name)];
                    var databaseName = (string)databaseValues[nameof(ShoppingListItem.Name)];
                    var proposedQty = entry.CurrentValues[nameof(ShoppingListItem.Quantity)] as decimal?;
                    var databaseQty = databaseValues[nameof(ShoppingListItem.Quantity)] as decimal?;

                    if (proposedName != databaseName || proposedQty != databaseQty)
                    {
                        // Get who made the other change
                        var otherUserId = databaseValues[nameof(ShoppingListItem.UpdatedByUserId)] as int?;

                        // For now, use last-write-wins for non-checkbox fields
                        // but record that there was a conflict
                        conflictMessage = $"Another family member also edited this item";
                    }

                    // Refresh original values to allow retry
                    entry.OriginalValues.SetValues(databaseValues);
                }
            }

            if (retries >= maxRetries)
            {
                return (false, true, "Could not save changes after multiple attempts");
            }
        }
    }

    return (true, wasConflict, conflictMessage);
}
```

Also update the existing UpdateItemAsync to use this new method or refactor to consolidate logic.
  </action>
  <verify>ShoppingListService has concurrency handling with retry loop</verify>
  <done>Shopping list updates handle concurrent edits with "checked wins"</done>
</task>

<task type="auto">
  <name>Task 2: Create ConflictIndicator component</name>
  <files>src/FamilyCoordinationApp/Components/ShoppingList/ConflictIndicator.razor</files>
  <action>
Create a small indicator that shows when an item had a conflict:

```razor
<MudTooltip Text="@Message" Placement="Placement.Top">
    <MudChip T="string"
             Size="Size.Small"
             Color="Color.Warning"
             Variant="Variant.Text"
             Icon="@Icons.Material.Filled.Warning">
        Synced
    </MudChip>
</MudTooltip>

@code {
    [Parameter]
    public string Message { get; set; } = "This item was modified by another family member";
}
```

This component provides a non-intrusive way to show that a conflict was resolved.
  </action>
  <verify>ConflictIndicator component compiles and renders warning chip</verify>
  <done>Conflict indicator shows resolved conflicts with message</done>
</task>

<task type="auto">
  <name>Task 3: Update ShoppingList page to use concurrency-aware updates</name>
  <files>src/FamilyCoordinationApp/Components/Pages/ShoppingList.razor</files>
  <action>
Update HandleItemChecked to use the new concurrency-aware method:

```csharp
private async Task HandleItemChecked(ShoppingListItem item)
{
    if (_currentList == null) return;

    try
    {
        var itemToToggle = item;

        // Toggle checked state
        item.IsChecked = !item.IsChecked;
        item.CheckedAt = item.IsChecked ? DateTime.UtcNow : null;

        var (success, wasConflict, conflictMessage) = await ShoppingListService.UpdateItemWithConcurrencyAsync(item);

        if (!success)
        {
            // Item was deleted or couldn't be updated
            Snackbar.Add(conflictMessage ?? "Could not update item", Severity.Warning);
            await LoadShoppingListsAsync();
            return;
        }

        if (wasConflict && conflictMessage != null)
        {
            // Show subtle indication that there was a conflict
            Snackbar.Add(conflictMessage, Severity.Info, config =>
            {
                config.VisibleStateDuration = 3000;
            });
        }

        StateHasChanged();

        // Show undo snackbar when checking item
        if (item.IsChecked)
        {
            Snackbar.Add($"Checked {item.Name}", Severity.Success, config =>
            {
                config.Action = "UNDO";
                config.VisibleStateDuration = 4000;
                config.OnClick = async (snackbar) =>
                {
                    itemToToggle.IsChecked = false;
                    itemToToggle.CheckedAt = null;
                    await ShoppingListService.UpdateItemWithConcurrencyAsync(itemToToggle);
                    StateHasChanged();
                    Snackbar.Add($"Unchecked {itemToToggle.Name}", Severity.Info);
                };
            });
        }
    }
    catch (Exception ex)
    {
        Snackbar.Add($"Error updating item: {ex.Message}", Severity.Error);
    }
}
```

Similarly update HandleItemEdit to use the concurrency-aware method.
  </action>
  <verify>ShoppingList page uses UpdateItemWithConcurrencyAsync</verify>
  <done>Shopping list operations handle concurrent updates gracefully</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete multi-user collaboration system including:
- User attribution on recipes and shopping list items
- Online presence indicators in header
- Sync status display
- Automatic refresh via polling (5-second interval)
- Optimistic concurrency with "checked wins" for shopping items
- Conflict indication for concurrent edits
  </what-built>
  <how-to-verify>
1. Open the app in two different browsers (or one incognito) with two different whitelisted users
2. Sign in as User A in browser 1, User B in browser 2
3. Verify User A sees User B in the header's "online users" display (and vice versa)
4. Verify sync status indicator shows "Synced" state
5. As User A, create a new recipe. Verify User B's recipe page auto-refreshes to show it (within ~10 seconds)
6. Navigate to Shopping List on both browsers
7. As User A, add an item manually. Verify it appears on User B's list automatically
8. Verify the item shows User A's avatar/initials
9. Simultaneously check off the same item on both browsers
10. Verify "checked wins" - the item should stay checked regardless of timing
11. As User A, edit an item's quantity. As User B, also edit the same item's name simultaneously
12. Verify both changes eventually sync (last-write-wins for non-checkbox fields)
13. Verify no errors appear and the app remains responsive
  </how-to-verify>
  <resume-signal>Type "approved" if collaboration works correctly, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. `dotnet build src/FamilyCoordinationApp` - No compilation errors
2. ShoppingListService.cs contains UpdateItemWithConcurrencyAsync with DbUpdateConcurrencyException handling
3. ConflictIndicator.razor exists with warning display
4. ShoppingList.razor uses the concurrency-aware update method
5. Human verification confirms multi-user workflow functions correctly
</verification>

<success_criteria>
- Multiple users can check items simultaneously without data loss
- "Checked wins" strategy ensures consistent state
- Concurrent edits don't crash or lose data
- Conflict messages are user-friendly (not technical errors)
- Human verifies end-to-end multi-user workflow
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-user-collaboration/05-07-SUMMARY.md`
</output>
